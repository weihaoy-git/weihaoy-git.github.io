{"pages":[],"posts":[{"title":"The C Programming Language Chapter-1","text":"Chapter-1 A Tutorial Introduction Notes of The C programming Language Integer Division of CIn C, integer division will truncate the result to zero, regardless of whether the result is positive or negative. printf Conversion Specification %fFor example, %6.4f means printf should print the value as floating point, at least 6 characters wide (it means the total width) and 4 after the decimal point. 123456789#include &lt;stdio.h&gt;int main() { float printFloatWidth1 = 1111.222; float printFloatWidth2 = 0.2; printf(&quot;printFloatWidth1: %6.4f\\n&quot;, printFloatWidth1); printf(&quot;printFloatWidth2: %6.2f\\n&quot;, printFloatWidth2); return 0;} 12printFloatWidth1: 1111.2220printFloatWidth2: 0.20 If the valid digits of the value cannot fill the least width, printf will fill it with spaces, as illustrated in printFloatWidth2. Symbolic Constants1#define PI 3.1415 Input and OutputC provides getchar() and putchar() as the user input/output interface. Comparing with InputStream and OutputStream in Java, input and output methods in C do not specify the source, destination and whether use buffer explicitly. getchar() and putchar() implicitly set console as input source and output destination, and enable buffer. It’s worth noting that \\n is not EOF. When we enter \\n in the terminal, the program will push the buffer (including \\n itself) to the while loop including getchar(). Then getchar() will read every character till the buffer is empty, and getchar() will block on it. Although the behaviors of this ‘echo’ program like it’s processing strings, it can only recognize characters one by one. A simple example 123456void copyInput() { int c; while ((c=getchar())!=EOF) { putchar(c); }} 1234567811145151451562365346236534 151 151 Declare functions in a compatible formatWe all know if you leave empty in the definition of C function argument list, it means this function need no argument. But for the compatibility with older C programs, it would be better to use void for an explicitly empty argument list. 12345678#include &lt;stdio.h&gt;int getLine(void);int copy(void);int main() { return 0;}","link":"/2021/12/10/The-C-Programming-Language-Chapter-1/"},{"title":"Go Programming Tips","text":"Add 0x prefix when printing hex numbersUse %#x placeholder. 12345func TestPrintHex() { var i int = 0x123456 fmt.Printf(&quot;%x\\n&quot;, i) fmt.Printf(&quot;%#x\\n&quot;, i)} 121234560x123456 Print the type of a variable123fmt.Printf(&quot;%T\\n&quot;, i)fmt.Println(reflect.Typeof(i))fmt.Prinft(&quot;%s\\n&quot;, reflect.Typeof(i).String()) Get random numbersIntn() returns the next integer in the current random sequence. UnixNano() returns the number of nanoseconds elapsed since January 1, 1970 UTC. And the result of UnixNano() does not depend on the location associated with t. We only have to set the seed once. But before we set the seed, rand will use the default seed. For example, the first call of Intn(100) always returns 81 without setting the seed. 12rand.Seed(time.Now().UnixNano())fmt.Println(rand.Intn(100)) Temporary variables in if-else blockIn Go, we can define variables in if-else condition statement. The scope of these temporary variables is limited within if-else block. 12345if v, p := math.Sqrt(float64(sum)), math.Sin(float64(sum)); v &lt; 10 &amp;&amp; p &lt; 0.5 { fmt.Println(&quot;True&quot;)} else { fmt.Println(v, p)} switchIn Go, the execution does not fall through the switch structure. Switch cases evaluate cases from top to bottom, stopping when a case succeeds. Also, if we want to take the same action on multiple cases, we can write case content1, content2:. In the following example, although without any break, the control flow jumps out of the switch block after executing the first case. 123456789var i int = 15640switch {case i &gt; 1: fmt.Println(i)case i &gt; 2: fmt.Println(i)case i &gt; 99999: fmt.Println(&quot;false&quot;)} 115640 SliceSlices share the same underlying memory with the original array. The type of slice is []T. len() returns the number of elements a slice contains. cap() returns the number of elements in the underlying array, counting from the first element in the slice. append(slice, e1, e2, ...) overwrites the elements in the underlying array if slice has enough capacity to contain these elements. Otherwise, it returns a new allocated slice and keeps the underlying array intact. 123456789101112131415161718192021222324func TestSlice() { var arr [5]int = [5]int{0, 1, 2, 3, 4} slice1 := arr[0:4] slice2 := arr[1:4] fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(arr).String(), len(arr), cap(arr)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice1).String(), len(slice1), cap(slice1)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice2).String(), len(slice2), cap(slice2)) slice1[0] = 9 fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2, &quot;\\n&quot;) // Test slice append slice3 := append(slice2, 8) // change the underlying array slice4 := append(slice2, 7, 6) // return a new allocated slice fmt.Println(arr, &amp;arr[0], cap(arr)) fmt.Println(slice1, &amp;slice1[0], cap(slice1)) fmt.Println(slice2, &amp;slice2[0], cap(slice2)) fmt.Println(slice3, &amp;slice3[0], cap(slice3)) fmt.Println(slice4, &amp;slice4[0], cap(slice4))} 123456789101112131415[0 1 2 3 4][0 1 2 3][1 2 3]type: [5]int, len: 5, cap: 5type: []int, len: 4, cap: 5type: []int, len: 3, cap: 4[9 1 2 3 4][9 1 2 3][1 2 3] [9 1 2 3 8] 0xc000018270 5[9 1 2 3] 0xc000018270 5[1 2 3] 0xc000018278 4[1 2 3 8] 0xc000018278 4[1 2 3 7 6] 0xc00001e080 8 Variable Length ArrayGo only allows constants to be used as array size. To create an array whose size is defined by a variabl, we can use make([]T, length). It creates an underlying array with size of length and returns a slice of it. 12345678910111213const conLen = 8func TestVLA(length int) { var l int = 5 // illegal //var arr0 [len]int //var arr1 [l]int var arr2 = make([]int, l) var arr3 = make([]int, length) var arr4 [conLen]int // do something} String comparisonIn Go, we can compare strings by using comparison operators (==, &lt;, &gt;, etc) or by strings.Compare(s1, s2). File naming conventionsnake_case is the convention across the most of the standard library and most third party libraries for Go. deferdefer FunctionCall() defers the execution of FunctionCall() until the surrounding function (the parent function call of FunctionCall()) returns. Multiple deferred calls are stacked, so that they will be callled in a LIFO order. 123456func TestDefer() { for i:= 0; i &lt; 5; i++ { defer fmt.Println(&quot;deferred call&quot;, i) } fmt.Println(&quot;ready to return&quot;)} 123456ready to returndeferred call 4deferred call 3deferred call 2deferred call 1deferred call 0 HashmapIn Go, we can declaring a hashmap by using key word map. map declares a non-thread-safe hashmap. Create a hash map: hashmap := make(map[string]int), string is key type and int is value type. Insert a key-value pair: hashmap[key] = value. Delete a key-value pair: delete(hashmap, key). Check whether a key exists: v, ok := hashmap[key]. If the key exists, ok == true. Otherwise, v equals to the zero value of the value type, ok == false. Traverse the hashmap: for k, v := range hashmap {// do someting} Difference between make and new make returns a value of T; new returns a value of *T. make returns an initialized value; new returns a zeroed value. make can only create and initialize slices, maps and channels; new can allocate zeroed memory for any types. Take hashmap as an example. Since we need to initialize structure of hashmap itself before using it (it means that we cannot just zero the hashmap memory), we have to create a hashmap by hashmap := make(map[string]int) or hashmap := map[string]int{}. Format go files recursively1go fmt path/... MethodIn Go, methods take either a value or a pointer as the receiver when they are called. Go interprets s.Print() as (&amp;s).Print(), ps.SwapPrint() as (*ps).SwapPrint(). But this is just syntactic sugar. Also, we cannot define new methods for existing types in another package (including built-in types, such as int, map). But it is fine to define a normal function that takes a non-local-package type argument. Or we can define our own alias for that type in current package type Alias ExistingTypeName, or define a wrapper structure containing that type type NewStruct struct {n ExistingTypeName} 1234567891011121314151617181920212223type MyStruct struct { x int y int}func (ps *MyStruct) Print() { fmt.Printf(&quot;(%d, %d)\\n&quot;, ps.x, ps.y)}func (s MyStruct) SwapPrint() { fmt.Printf(&quot;(%d, %d)\\n&quot;, s.y, s.x)}func TestMethod() { ps := new(MyStruct) ps.x = 12 ps.y = 24 s := MyStruct{12, 24} ps.Print() ps.SwapPrint() s.Print() s.SwapPrint()} InterfaceAny concrete types that implement all methods of a interface type satisfy implicitly that interface type. In other words, a interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. Note that T and *T are different when it comes to the relationship between interfaces and concrete types. And we cannot define methods for types under another package. 12345678910111213141516171819202122232425type IntTask inttype FloatTask float64type Runner interface { Run()}func (pit *IntTask) Run() { fmt.Printf(&quot;running task id = %d\\n&quot;, int(*pit))}func TestInterface() { var task Runner var pit *IntTask = new(IntTask) *pit = 1 var it IntTask = 2 fmt.Println(int(*pit)) fmt.Println(int(it)) task = pit // illegal //task = id task.Run()} Since only *ID implements Run() method, *ID satisfies interface Runnable but ID does not. 12312running task id = 1 Empty interfaceinterface{} is empty interface. Because it has no methods, all types satisfy the empty interface. Interface PitfallAn interface value with a nil dynamic value is NOT the same as a nil interface for any non-empty interfaces. If we assign nil to an empty interface variable, that variable is still equal to nil. If you want to keep the interface value consistent with its concrete value, please do not define a concrete value first then assign it to the interface value, but define the interface value directly (allocate a concrete value by new). 1234567891011func TestPitfall() { var pit *IntTask // zeroed as nil var run1 Runner = pit // warning: run1 is not nil var run2 Runner // zeroed as nil var run3 Runner = new(IntTask) var emptyInterface interface{} = nil fmt.Printf(&quot;run1 == nil ? %t\\n&quot;, run1 == nil) fmt.Printf(&quot;run2 == nil ? %t\\n&quot;, run2 == nil) fmt.Printf(&quot;run3 == nil ? %t\\n&quot;, run3 == nil) fmt.Printf(&quot;emptyInterface == nil ? %t\\n&quot;, emptyInterface == nil)} 1234run1 == nil ? falserun2 == nil ? truerun3 == nil ? falseemptyInterface == nil ? true Sortsort.Ints() and sort.Strings() only accept slice as argument. sort.Sort() provide a customizable method that requires the data type to be sorted should implement Len(), Swap() and Less(). 12var arr = [10]int{2, 3, 4, 6, 7, 9, 2, 3, 4, 5}sort.Ints(arr[:]) Type AssertionThe general form of type assertion is x.(T), while x is an interface to be tested (asserted), T can be a concrete type or another interface type. There are two usages of type assertion. T is a concrete type. The type assertion checks whether the concrete type of x is identical to T. T is an interface type. The type assertion checks whether the concrete type of x satisfies interface T. A successful type assertion returns the dynamic value in type T, and an optional assertion flag. A failed type assertion returns nil and flag false, if the statement only accepts one return value, it will cause a panic. 123456789101112131415161718192021func TestTypeAssert() { var itRunner Runner = new(IntTask) var ftRunner Runner = new(FloatTask) itRunner.Run() ftRunner.Run() // if without ok flag, such as pit2 := ftRunner.(*IntTask) // false assertions will cause panic pit, okInt := itRunner.(*IntTask) pit2, okInt2 := ftRunner.(*IntTask) pft, okFloat := ftRunner.(*FloatTask) pft2, okFloat2 := itRunner.(*FloatTask) fmt.Printf(&quot;assert itRunner to *IntTask: %t %T %p\\n&quot;, okInt, pit, pit) fmt.Printf(&quot;assert ftRunner to *IntTask: %t %T %p\\n&quot;, okInt2, pit2, pit2) fmt.Printf(&quot;assert ftRunner to *FloatTask: %t %T %p\\n&quot;, okFloat, pft, pft) fmt.Printf(&quot;assert itRunner to *FloatTask: %t %T %p\\n&quot;, okFloat2, pft2, pft2) *pit = 15640 *pft = 15.64 itRunner.Run() ftRunner.Run()} Type SwitchWe can use a type switch statement to replace an if-else chain of type assertions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func TestTypeSwitch() { var i int = 15640 var j float64 = 15.64 var k string = &quot;DS&quot; TypeSwitch1(i) TypeSwitch1(j) TypeSwitch1(k) fmt.Println(&quot;&quot;) TypeSwitch2(i) TypeSwitch2(j) TypeSwitch2(k) fmt.Println(&quot;&quot;) TypeSwitch3(i) TypeSwitch3(j) TypeSwitch3(k) fmt.Println(&quot;&quot;)}func TypeSwitch1(x interface{}) { switch x := x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch2(x interface{}) { switch x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch3(x interface{}) { switch x := x.(type) { case int, float64: fmt.Printf(&quot;Valid Type: %T\\n&quot;, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }} 1234567891011case int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected Typecase int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected TypeValid Type: intValid Type: float64Unexpected Type map, channel and reference in GoFirst of all, there is NO strict reference (alias) in Go, which means two variables refer (not point) to the same memeory location. In Go, everything is passed by value. But we can see that in Go map and channel can be passed by reference in function. This is because map and channel are pointers naturally, while do not look like pointers. For example, a map variable is actually a pointer to a runtime.hmap structure. By the way, channels act as FIFO queues. Closed and drained channelRead requests (not matter how many times) to a closed and drained channel always immediately returns a zero value. But we can examine receives on a closed and drained channel by using optional flag. 1234567891011func TestChannel() { channel := make(chan int, 10) close(channel) for { x, ok := &lt;- channel if !ok { break } fmt.Println(x) }} Or we can read elements from a channel by range, which will terminate the loop after reading the last element in a closed channel. 12345678910func TestChannel() { channel := make(chan int, 10) channel &lt;- 1 channel &lt;- 2 channel &lt;- 3 close(channel) for x := range channel { fmt.Println(x) }} Unidirectional channel typeschan&lt;- T: send-only channel; &lt;-chan T: receive-only channel. They can be used in function arguments to restrict the opertions to channels. Conversions from bidirectional channel to unidirectional channel types are permitted in any assignment. But there is no going back. nil channelSend and receive operations on a nil channel block forever. selectIn select, each case specifies a communication (a send or receive operation on some channel) and an associated block of statements. If there is only one runnable case, execute that case. If there is multiple runnable cases, randomly execute one of them. If there is no runnable cases, block. The default case in a select is run if no other case is ready. We can use select and a closed channel to terminate goroutines politely. Terminate a goroutineFirst, there is no way for one goroutine to terminate another directly. If we want to terminate a goroutine, we should send a “signal” to that goroutine and let it handles the signal by executing return. This signal can be implemented by a closed and drained channel. Because each receive operations to a closed and drained channel always immediately returns a zero value. It sounds great, right? But the problem is that if a goroutine is blocked, it cannot notice the signal at the same time. Thus, we need to ensure two things: If this routine may be blocked by other methods (listener.Accept(), etc), unblock these methods in Close(), for example, by listener.Close(). If this routine may be blocked by channel operations, always wrap every channel operation with a select-done structure. In other words, every channel operation should have a done case in parallel. 1234567891011121314151617181920212223242526272829var done = make(chan bool) // always emptyvar workChan = make(chan int, 10) // a buffered channel storing datafunc Close() { // broadcast termination signal close(done)}func sampleRoutine() { // ... select { case workChan &lt;- data: // do some non-blocking tasks case &lt;-done: return } // ...}func sampleRoutine2() { // ... select { default: // do some non-blocking tasks case &lt;-done: return } // ...} If we use for range to receive data from a channel in a goroutine function, which makes it hard to receive the termination signal, it can be rewritten by for{} and select. 123456789101112131415161718192021func sampleForRange() { // terminate loop automatically when workChan is closed and drained // cannot receive for res := range workChan { // ... }}func sampleForSelect() { for { select { case res, ok := &lt;-workChan: if !ok { // workChan is closed and drained return } // ... case &lt;-done: return } }} An ingenious example of decoupling on channel operation12345678910111213141516171819202122// work routine pulls integers from input channel// squares them and pushes results to output channelfunc (sq *SquarerImpl) work() { var toPush int dummy := make(chan int) pushOn := dummy pullOn := sq.input for { select { case unsquared := &lt;-pullOn: toPush = unsquared * unsquared pushOn = sq.output pullOn = nil case pushOn &lt;- toPush: pushOn = dummy pullOn = sq.input case &lt;-sq.close: sq.closed &lt;- true return } }} The constant generator iotaIn a const declaration, the value of iota begins at zero and increments by one for each item in the sequence. 1234567891011121314151617181920const ( zero = iota // 0 one // 1 two // 2 three // 3 four // 4)const ( first = 1 + iota // 1 second // 2 third // 3)const ( _ = 1 &lt;&lt; (10 * iota) KB // 1024 MB // 1024 * 1024 GB // 1024 * 1024 * 1024) Asynchronous Request Implementation12345type Request struct { reqType ReqType retChan chan interface{} reqBody []interface{}} Remove the first element of a sliceIt also applies on slices with length of 1. 1slice = slice[1:] json.Marshaljson.Marshal(v) takes a memory object (argument type interface{}) and return its json encoding. In network programming, it can conveniently convert a user-defined object into json payload of the packet. Flexible array members in a structureGo allows us to define flexible array members (slices) in structures. Different from C, we can define any number of slices at any places in a structure. 123456789101112131415type Struct1 struct { i int body []interface{}}type Struct2 struct { body []interface{}}type Struct3 struct { i int body1 []interface{} body2 []interface{} j int} Pop from a slices = s[1:]. It removes the first element of s. Note that when using this syntax, the length of s can be 1 or greater but cannot be 0. 12345678func TestSlicePop() { s := make([]int, 1) s[0] = 16540 s = s[1:] // remove the first element fmt.Println(len(s)) // print 0 s1 := make([]int, 0) s1 = s1[1:] // ERROR!} Delete from a mapDeleting a non-existing key from a map through delete() makes no effect. 12345678func TestMapDelete() { hashmap := make(map[int]int) hashmap[1] = 1 delete(hashmap, 0) for k, v := range hashmap { fmt.Printf(&quot;[%d, %d]\\n&quot;, k, v) }} 1[1, 1] Constants in GoGo does NOT support constant members in structures or constant structures. Implement timing events by tickerWe can create a ticker through time.NewTicker(interval), which generates ticks in its channel ticker.C at specified time intervals (obviously, the size of channel C is one. We do not want ticks to be accumulated). We can place the handling functions of timing events and other events in a for-select block, so that timing events will not affect the execution of normal events. Note that Stop() will stop sending ticks to the channel C but will not close it, to prevent a closed drained channel issue. 123456789101112func TestTicker() { ticker := time.NewTicker(10 * time.Second) //ticker.Stop() for { select { case t := &lt;-ticker.C: // timing event fmt.Println(t) // case e := &lt;-normalEventChan: } }} Implicit type conversions and implicit numeric conversionsGo does not allow implicit type conversions, and does not allow implicit numeric conversions except numeric conversions across constants. 12345678910111213141516171819202122232425262728func TestType() { var i int = 10 var j int64 = 10 var k int = 10 // 1/10 == 0 =&gt; 0.0 var p float64 = 1 / 10 // 1.0/10 =&gt; 1.0/10.0 =&gt; 0.1 var q float64 = 1.0 / 10 // illegal // var m float64 = 1.0 / i _ = j // to keep compiler happy // mismatched types // j = i // mismatched types /* if i == j { fmt.Println(&quot;i == j&quot;) } */ if i == k { fmt.Println(&quot;i == k&quot;) } fmt.Println(p) fmt.Println(q) // Go does not support implicit numeric conversion // p = i / k} 123i == k00.1","link":"/2021/12/22/Go-Programming-Tips/"},{"title":"Java Programming Tips","text":"Convert char to int12char c = '9';int i = Character.getNumericValue(c); 12char c = '9';int i = c - '0'; Add zeros at the beginning of a number12int i = 640;System.out.printf(&quot;%05d\\n&quot;, i); 100640 Fill an arrayUse Arrays.fill(array, val) to assign values to an array. 123int[] a = new int[10];Arrays.fill(a, 7);System.out.println(Arrays.toString(a)); 1[7, 7, 7, 7, 7, 7, 7, 7, 7, 7] Convert between string and char array123char[] arr = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};String s = new String(arr);char[] arr2 = s.toCharArray(); Default initialization of an array in JavaEverything in a Java program not explicitly set to something by the programmer, is initialized to a zero value. For references (anything that holds an object) that is null. For int/short/byte/long that is a 0. For float/double that is a 0.0 For booleans that is a false. For char that is the null character '\\u0000' (whose decimal equivalent is 0). Reverse a List1Collections.reverse(list); Create a List from an arrayTake the return of Array.asList() as the parameter of ArrayList constructor. 12int[] array = new int[10];ArrayList&lt;Integer&gt; arraylIST = new ArrayList&lt;&gt;(Arrays.asList(array)); Sort Primitive array: Arrays.sort(arr) Object array: Arrays.sort(integerArr, comparator) List: Collections.sort(list, comparator) 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Traverse a mapUse Map.Entry or HashMap.Entry. 1234HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();for (HashMap.Entry&lt;Integer, Integer&gt; e:hashMap.entrySet()) { // do something} isLetter() and isAlphabetic()isLetter() and isAlphabetic() are two methods of Character. The difference between them is: isAlphabetic() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER &amp;&amp; LETTER_NUMBER. isLetter() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER. The point is that isLetter() will return false given a letter number. For example, roman numeral five (the letter looks like “V”). Certainly, for the English language, the distinction makes no difference. Use Deque over Stack for LIFO stacksWe should use Deque rather than Stack for LIFO stacks. 12Deque&lt;Integer&gt; dstack = new ArrayDeque&lt;&gt;();Stack&lt;Integer&gt; sstack = new Stack&lt;&gt;(); // not recommended There are many reasons to prefer Deque: Deque is an interface but Stack is a class. So using Deque brings us more flexibility for future extension. Stack is synchronized but Deque is not thread-safe. In the case of no need to ensure thread safety, Deque is more efficient. Deque iterates elements from top to bottom. Stack iterates elements from bottom to top. Most important: with Stack, we can access/insert/remove arbitrary elements in the LIFO stack by indexes, stack.get(index); stack.add(index, e); stack.remove(index), which breaks the LIFO rule. Although Deque does not absolutely obey the LIFO rule, it can only access/insert/remove the first/last element in the LIFO stack. Print multi-dimensional arrays12System.out.println(Arrays.toString(arr)); // print a 1D arraySystem.out.println(Arrays.deepToString(marr)); // print a multi-dimensional array Get ceiling/floor value of a number12double ceilingValue = Math.ceil(3.1); // 4.0double floorValue = Math.floor(3.1); // 3.0 Note that these twoMath functions return double. Or if we need to get the ceiling value of a fraction X/Y, we can also do as the following: 1int res = (X + Y - 1) / Y; Sort an array/list Primitive array int[]: Arrays.sort Objective array Integer[]: Arrays.sort and optional comparator Objective list List&lt;Integer&gt;: Collections.sort and optional comparator 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Common time complexity calculation$$\\sum_{1}^{n}{k^2}=\\frac{1}{n}{n(n+1)(2n+1)}=O(n^3)\\\\sum_{1}^{n}{k^3}=(\\frac{1}{2}{n(n+1)})^2=O(n^4)$$ String manipulation1234StringBuilder builder1 = new StringBuilder(&quot;abcdefg&quot;);// if we want to delete c and add it backbuilder1.deleteCharAt(2); // &quot;abdefg&quot;builder1.insert(2, 'c'); // &quot;abcdefg&quot; toCharArray() and getBytes()toCharArray() is better if we are not dealing with characters outside of the Unicode BMP, which are encoded as two surrogate characters. getBytes() needs to specify encoding, which is prone to mistakes. Also, toCharArray() is faster because for Java 7 and newer, a String object contains a char array internally. toCharArray() just need to complete a copy operation.","link":"/2021/12/22/Java-Programming-Tips/"},{"title":"A Brief Introduction to Dynamic Programming","text":"Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. example 123456789101112131415161718192021// recursionpublic int fib(int n) { if(n&lt;=1) return n; return fib(n-1)+fib(n-2);}// dynamic programmingpublic int fibDP(int n) { if (n&gt;1) { int fib=0, p1=1,p2=0; for (int i=2;i&lt;=n;i++) { fib = p1+p2; p2 = p1; p1 = fib; } return fib; } else if (n==1) { return 1; } else { return 0; }} Two pattern of solving DP problem: Tabulation: bottom up Memoization: top down","link":"/2021/12/22/A-Brief-Introduction-to-Dynamic-Programming/"},{"title":"OA Count Analogous Arrays","text":"QuestionAn array is said to be analogous to the secret array if all of the following conditions are true:• The length of the array is equal to the length of the secret array.• Each integer in the array lies in the interval [lowerBound, upperBound].• The difference between each pair of consecutive integers of the array must be equal to the difference between the respective pair of consecutive integers in the secret array. In other words, let the secret array be [s[0], s[1],…, s[n-1]] and let the analogous array be [a[0], a[1],…, a[n-1]], then (a[i-1] - a[i]) must be equal to (s[i-1] - s[i]) for each i from 1 to n -1. Given the value of integers lowerBound and upperBound, inclusive, and the array of differences between each pair of consecutive integers of the secret array, find the number of arrays that are analogous to the secret array. If there is no array analogous to the secret array, return 0. For example:consecutiveDifference = [-2, -1, -2, 5]lowerBound = 3upperBound = 10 Note that none of the values is out of the bound. All possible analogous arrays are:[3, 5, 6, 8, 3][4, 6, 7, 9, 4][5, 7, 8, 10, 5] Tha answer is 3. Source: https://leetcode.com/discuss/interview-question/1332322/amazon-online-assessment-july-2021-secret-array Solution123456789101112131415161718public static int countAnalogousArrays(int[] consecutiveDifference, int lowerBound, int upperBound) { // parameter validation if (consecutiveDifference == null || consecutiveDifference.length &lt; 1 || lowerBound &gt; upperBound) { return 0; } int delta = 0, maxDelta = 0, minDelta = 0; for (int i = 0; i &lt; consecutiveDifference.length; i++) { delta += consecutiveDifference[i]; maxDelta = Math.max(maxDelta, delta); minDelta = Math.min(minDelta, delta); } int maxDiff = maxDelta - minDelta, boundGap = upperBound - lowerBound; // max difference exceeds bound gap if (maxDiff &gt; boundGap) { return 0; } return boundGap - maxDiff;}","link":"/2021/12/29/OA-Count-Analogous-Arrays/"},{"title":"LeetCode 696. Count Binary Substrings","text":"QuestionGive a binary string s, return the number of non-empty substrings that have the same number of 0‘s and 1‘s, and all the 0‘s and all the 1‘s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: 12345Input: s = &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: 123Input: s = &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1's and 0's. Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either '0' or '1'. Source: https://leetcode.com/problems/count-binary-substrings/ SolutionRepresent the string as groups of continuous 1s and 0s. The question requires “substrings”, which greatly simplifies the solution since characters in a substring must be continuous in the original string. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// group// Time Complexity: O(N), Space Complexity: O(N)public int countBinarySubstrings(String s) { // parameter validation if (s == null || s.length() &lt; 1) { return 0; } int len = s.length(); int[] group = new int[len]; int lastGroupIndex = 0; group[0] = 1; // get 0,1 distribution // [3, 2, 4, 1] for &quot;1110011110&quot; for (int i = 1; i &lt; len; i++) { if (s.charAt(i - 1) != s.charAt(i)) { lastGroupIndex++; group[lastGroupIndex] = 1; } else { group[lastGroupIndex]++; } } int result = 0; for (int i = 1; i &lt;= lastGroupIndex; i++) { result += Math.min(group[i - 1], group[i]); } return result;}// space optimized// like Fibonacci sequence// Time Complexity: O(N), Space Complexity: O(1)public int countBinarySubstrings2(String s) { // parameter validation if (s == null || s.length() &lt; 1) { return 0; } int len = s.length(); int result = 0, lastGroupNum = 0, currGroupNum = 1; for (int i = 1; i &lt; len; i++) { if (s.charAt(i - 1) != s.charAt(i)) { // update result at the start of a new group result += Math.min(lastGroupNum, currGroupNum); lastGroupNum = currGroupNum; currGroupNum = 1; } else { currGroupNum++; } } // handle corner case result += Math.min(lastGroupNum, currGroupNum); return result;}","link":"/2021/12/29/LeetCode-696-Count-Binary-Substrings/"},{"title":"LeetCode 134. Gas Station","text":"QuestionThere are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Example 1: 12345678910Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2: 123456789Input: gas = [2,3,4], cost = [3,4,3]Output: -1Explanation:You can't start at station 0 or 1, as there is not enough gas to travel to the next station.Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can't travel around the circuit once no matter where you start. Constraints: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 Source: https://leetcode.com/problems/gas-station/ SolutionWe can abstract this problem as following: Given a delta array int[] delta, find a routine that sequentially traverses the array and makes the sum of $\\delta$ always above or equal to zero during traversal, and return the start index of this routine. If there is no such routine, return -1. There are two critical properities, we will prove and explain them later: If $\\sum_{i=0}^{n-1}{\\delta_i} \\ge0$, there must be at least one valid routine. If $\\sum_{i=p}^{q}{\\delta_i} &lt;0$ and $\\delta_p \\ge0$, any indice between $p$ and $q$ (inclusive) are not the start index of a valid routine. According to these two properties, we just need to traverse the array twice, one for checking whether a solution exists, the other for finding the first solution. Proof for the first property (Mathematical induction): Proof for the second property (better to understand by intuition): Note that just from the sum of the whole delta array, we cannot determine the number of solutions. Multiple solutions may exist when the sum is zero or greater than zero. For example, [1, 2, 3, 4] and [1, -1, 1, -1]. These two properties can also be used on many other situations. 1234567891011121314151617181920212223// two-pass, can be merged into one passpublic int canCompleteCircuit(int[] gas, int[] cost) { int len = gas.length; int totalTank = 0; // check if there is a solution for (int i = 0; i &lt; len; i++) { totalTank += gas[i] - cost[i]; } if (totalTank &lt; 0) { return -1; } // if solution exists, find a solution int currTank = 0; int startIndex = 0; for (int i = 0; i &lt; len; i++) { currTank += gas[i] - cost[i]; if (currTank &lt; 0) { // set i+1 as the start station and reset tank to zero startIndex = i + 1; currTank = 0; } } return startIndex;}","link":"/2021/12/29/LeetCode-134-Gas-Station/"},{"title":"LeetCode 1048. Longest String Chain","text":"QuestionYou are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;, while &quot;cba&quot; is not a predecessor of &quot;bcad&quot;. A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1. Return the length of the longest possible word chain with words chosen from the given list of words. Example 1: 123Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]Output: 4Explanation: One of the longest word chains is [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]. Example 2: 123Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]Output: 5Explanation: All the words can be put in a word chain [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;]. Example 3: 1234Input: words = [&quot;abcd&quot;,&quot;dbqca&quot;]Output: 1Explanation: The trivial word chain [&quot;abcd&quot;] is one of the longest word chains.[&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed. Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 16 words[i] only consists of lowercase English letters. Source: https://leetcode.com/problems/longest-string-chain/ SolutionBottom-Up DP For words, the length of longest string chain that ends with word equals $max(pre_0(word),pre_1(word),…,pre_{l-1}(word))+1$ 1234567891011121314151617181920212223242526272829303132public int longestStrChain(String[] words) { // parameter validation if (words == null || words.length &lt; 1) { return 0; } // s -&gt; max length of string chain ending with s Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); // sort words by length of each word Arrays.sort(words, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }); int len = words.length; int maxLen = 0; for (int i = 0; i &lt; len; i++) { int currLen = 1; StringBuilder temp = new StringBuilder(words[i]); for (int k = 0; k &lt; words[i].length(); k++) { char c = temp.charAt(k); temp.deleteCharAt(k); String predecessor = temp.toString(); int prevLen = cache.getOrDefault(predecessor, 0); currLen = Math.max(currLen, prevLen + 1); temp.insert(k, c); // restore the change } cache.put(words[i], currLen); maxLen = Math.max(maxLen, currLen); } return maxLen;}","link":"/2021/12/30/LeetCode-1048-Longest-String-Chain/"},{"title":"LeetCode 271. Encode and Decode String","text":"QuestionDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: 1234string encode(vector&lt;string&gt; strs) { // ... your code return encoded_string;} Machine 2 (receiver) has the function: 1234vector&lt;string&gt; decode(string s) { //... your code return strs;} So Machine 1 does: 1string encoded_string = encode(strs); and Machine 2 does: 1vector&lt;string&gt; strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. You are not allowed to solve the problem using any serialize methods (such as eval). Example 1: 1234567891011Input: dummy_input = [&quot;Hello&quot;,&quot;World&quot;]Output: [&quot;Hello&quot;,&quot;World&quot;]Explanation:Machine 1:Codec encoder = new Codec();String msg = encoder.encode(strs);Machine 1 ---msg---&gt; Machine 2Machine 2:Codec decoder = new Codec();String[] strs = decoder.decode(msg); Example 2: 12Input: dummy_input = [&quot;&quot;]Output: [&quot;&quot;] Constraints: 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] contains any possible characters out of 256 valid ASCII characters. Source: https://leetcode.com/problems/encode-and-decode-strings/ SolutionThe best solution is to add a header that represents the length of each string instead of using delimiter. Strings will be concatenated as header-payload-header-.... Note that we call toCharArray method rather than getBytes(). We do not care about the content of payload so that we do not need to encode/decode strings. Also, on some OA platforms, we may need to import desired character set manually. 123456789101112131415161718192021222324252627282930313233343536373839404142// encode a 32-bit integer to a char array, according to little endian// then convert the byte array into a stringprivate String int2string(int len) { char[] bytes = new char[4]; for (int i = 0; i &lt; 4; i++) { bytes[i] = (char) ((len &gt;&gt; (i * 8)) &amp; 0xff); } return new String(bytes);}// decode a 32-bit string to intprivate int string2int(String s) { char[] bytes = s.toCharArray(); int len = 0; for (int i = 0; i &lt; 4; i++) { len += ((int) (bytes[i])) &lt;&lt; (i * 8); } return len;}// Encodes a list of strings to a single string.public String encode(List&lt;String&gt; strs) { StringBuilder builder = new StringBuilder(); for (String str : strs) { builder.append(int2string(str.length())); builder.append(str); } return builder.toString();}// Decodes a single string to a list of strings.public List&lt;String&gt; decode(String s) { int i = 0; List&lt;String&gt; res = new ArrayList&lt;&gt;(); while (i &lt; s.length()) { int strLen = string2int(s.substring(i, i + 4)); i += 4; res.add(s.substring(i, i + strLen)); i += strLen; } return res;}","link":"/2021/12/30/LeetCode-271-Encode-and-Decode-String/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Substring","slug":"Substring","link":"/tags/Substring/"},{"name":"Delta","slug":"Delta","link":"/tags/Delta/"}],"categories":[{"name":"C - K&amp;R","slug":"C-K-R","link":"/categories/C-K-R/"},{"name":"Programming Tips","slug":"Programming-Tips","link":"/categories/Programming-Tips/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}