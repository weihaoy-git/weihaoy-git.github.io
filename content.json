{"pages":[],"posts":[{"title":"The C Programming Language Chapter-1","text":"Chapter-1 A Tutorial Introduction Notes of The C programming Language Integer Division of CIn C, integer division will truncate the result to zero, regardless of whether the result is positive or negative. printf Conversion Specification %fFor example, %6.4f means printf should print the value as floating point, at least 6 characters wide (it means the total width) and 4 after the decimal point. 123456789#include &lt;stdio.h&gt;int main() { float printFloatWidth1 = 1111.222; float printFloatWidth2 = 0.2; printf(&quot;printFloatWidth1: %6.4f\\n&quot;, printFloatWidth1); printf(&quot;printFloatWidth2: %6.2f\\n&quot;, printFloatWidth2); return 0;} 12printFloatWidth1: 1111.2220printFloatWidth2: 0.20 If the valid digits of the value cannot fill the least width, printf will fill it with spaces, as illustrated in printFloatWidth2. Symbolic Constants1#define PI 3.1415 Input and OutputC provides getchar() and putchar() as the user input/output interface. Comparing with InputStream and OutputStream in Java, input and output methods in C do not specify the source, destination and whether use buffer explicitly. getchar() and putchar() implicitly set console as input source and output destination, and enable buffer. It’s worth noting that \\n is not EOF. When we enter \\n in the terminal, the program will push the buffer (including \\n itself) to the while loop including getchar(). Then getchar() will read every character till the buffer is empty, and getchar() will block on it. Although the behaviors of this ‘echo’ program like it’s processing strings, it can only recognize characters one by one. A simple example 123456void copyInput() { int c; while ((c=getchar())!=EOF) { putchar(c); }} 1234567811145151451562365346236534 151 151 Declare functions in a compatible formatWe all know if you leave empty in the definition of C function argument list, it means this function need no argument. But for the compatibility with older C programs, it would be better to use void for an explicitly empty argument list. 12345678#include &lt;stdio.h&gt;int getLine(void);int copy(void);int main() { return 0;}","link":"/2021/12/10/The-C-Programming-Language-Chapter-1/"},{"title":"Go Programming Tips","text":"Add 0x prefix when printing hex numbersUse %#x placeholder. 12345func TestPrintHex() { var i int = 0x123456 fmt.Printf(&quot;%x\\n&quot;, i) fmt.Printf(&quot;%#x\\n&quot;, i)} 121234560x123456 Print the type of a variable123fmt.Printf(&quot;%T\\n&quot;, i)fmt.Println(reflect.Typeof(i))fmt.Prinft(&quot;%s\\n&quot;, reflect.Typeof(i).String()) Get random numbersIntn() returns the next integer in the current random sequence. UnixNano() returns the number of nanoseconds elapsed since January 1, 1970 UTC. And the result of UnixNano() does not depend on the location associated with t. We only have to set the seed once. But before we set the seed, rand will use the default seed. For example, the first call of Intn(100) always returns 81 without setting the seed. 12rand.Seed(time.Now().UnixNano())fmt.Println(rand.Intn(100)) Temporary variables in if-else blockIn Go, we can define variables in if-else condition statement. The scope of these temporary variables is limited within if-else block. 12345if v, p := math.Sqrt(float64(sum)), math.Sin(float64(sum)); v &lt; 10 &amp;&amp; p &lt; 0.5 { fmt.Println(&quot;True&quot;)} else { fmt.Println(v, p)} switchIn Go, the execution does not fall through the switch structure. Switch cases evaluate cases from top to bottom, stopping when a case succeeds. Also, if we want to take the same action on multiple cases, we can write case content1, content2:. In the following example, although without any break, the control flow jumps out of the switch block after executing the first case. 123456789var i int = 15640switch {case i &gt; 1: fmt.Println(i)case i &gt; 2: fmt.Println(i)case i &gt; 99999: fmt.Println(&quot;false&quot;)} 115640 SliceSlices share the same underlying memory with the original array. The type of slice is []T. len() returns the number of elements a slice contains. cap() returns the number of elements in the underlying array, counting from the first element in the slice. append(slice, e1, e2, ...) overwrites the elements in the underlying array if slice has enough capacity to contain these elements. Otherwise, it returns a new allocated slice and keeps the underlying array intact. 123456789101112131415161718192021222324func TestSlice() { var arr [5]int = [5]int{0, 1, 2, 3, 4} slice1 := arr[0:4] slice2 := arr[1:4] fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(arr).String(), len(arr), cap(arr)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice1).String(), len(slice1), cap(slice1)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice2).String(), len(slice2), cap(slice2)) slice1[0] = 9 fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2, &quot;\\n&quot;) // Test slice append slice3 := append(slice2, 8) // change the underlying array slice4 := append(slice2, 7, 6) // return a new allocated slice fmt.Println(arr, &amp;arr[0], cap(arr)) fmt.Println(slice1, &amp;slice1[0], cap(slice1)) fmt.Println(slice2, &amp;slice2[0], cap(slice2)) fmt.Println(slice3, &amp;slice3[0], cap(slice3)) fmt.Println(slice4, &amp;slice4[0], cap(slice4))} 123456789101112131415[0 1 2 3 4][0 1 2 3][1 2 3]type: [5]int, len: 5, cap: 5type: []int, len: 4, cap: 5type: []int, len: 3, cap: 4[9 1 2 3 4][9 1 2 3][1 2 3] [9 1 2 3 8] 0xc000018270 5[9 1 2 3] 0xc000018270 5[1 2 3] 0xc000018278 4[1 2 3 8] 0xc000018278 4[1 2 3 7 6] 0xc00001e080 8 Variable Length ArrayGo only allows constants to be used as array size. To create an array whose size is defined by a variabl, we can use make([]T, length). It creates an underlying array with size of length and returns a slice of it. 12345678910111213const conLen = 8func TestVLA(length int) { var l int = 5 // illegal //var arr0 [len]int //var arr1 [l]int var arr2 = make([]int, l) var arr3 = make([]int, length) var arr4 [conLen]int // do something} String comparisonIn Go, we can compare strings by using comparison operators (==, &lt;, &gt;, etc) or by strings.Compare(s1, s2). File naming conventionsnake_case is the convention across the most of the standard library and most third party libraries for Go. deferdefer FunctionCall() defers the execution of FunctionCall() until the surrounding function (the parent function call of FunctionCall()) returns. Multiple deferred calls are stacked, so that they will be callled in a LIFO order. 123456func TestDefer() { for i:= 0; i &lt; 5; i++ { defer fmt.Println(&quot;deferred call&quot;, i) } fmt.Println(&quot;ready to return&quot;)} 123456ready to returndeferred call 4deferred call 3deferred call 2deferred call 1deferred call 0 HashmapIn Go, we can declaring a hashmap by using key word map. map declares a non-thread-safe hashmap. Create a hash map: hashmap := make(map[string]int), string is key type and int is value type. Insert a key-value pair: hashmap[key] = value. Delete a key-value pair: delete(hashmap, key). Check whether a key exists: v, ok := hashmap[key]. If the key exists, ok == true. Otherwise, v equals to the zero value of the value type, ok == false. Traverse the hashmap: for k, v := range hashmap {// do someting} Difference between make and new make returns a value of T; new returns a value of *T. make returns an initialized value; new returns a zeroed value. make can only create and initialize slices, maps and channels; new can allocate zeroed memory for any types. Take hashmap as an example. Since we need to initialize structure of hashmap itself before using it (it means that we cannot just zero the hashmap memory), we have to create a hashmap by hashmap := make(map[string]int) or hashmap := map[string]int{}. Format go files recursively1go fmt path/... MethodIn Go, methods take either a value or a pointer as the receiver when they are called. Go interprets s.Print() as (&amp;s).Print(), ps.SwapPrint() as (*ps).SwapPrint(). But this is just syntactic sugar. Also, we cannot define new methods for existing types in another package (including built-in types, such as int, map). But it is fine to define a normal function that takes a non-local-package type argument. Or we can define our own alias for that type in current package type Alias ExistingTypeName, or define a wrapper structure containing that type type NewStruct struct {n ExistingTypeName} 1234567891011121314151617181920212223type MyStruct struct { x int y int}func (ps *MyStruct) Print() { fmt.Printf(&quot;(%d, %d)\\n&quot;, ps.x, ps.y)}func (s MyStruct) SwapPrint() { fmt.Printf(&quot;(%d, %d)\\n&quot;, s.y, s.x)}func TestMethod() { ps := new(MyStruct) ps.x = 12 ps.y = 24 s := MyStruct{12, 24} ps.Print() ps.SwapPrint() s.Print() s.SwapPrint()} InterfaceAny concrete types that implement all methods of a interface type satisfy implicitly that interface type. In other words, a interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. Note that T and *T are different when it comes to the relationship between interfaces and concrete types. And we cannot define methods for types under another package. 12345678910111213141516171819202122232425type IntTask inttype FloatTask float64type Runner interface { Run()}func (pit *IntTask) Run() { fmt.Printf(&quot;running task id = %d\\n&quot;, int(*pit))}func TestInterface() { var task Runner var pit *IntTask = new(IntTask) *pit = 1 var it IntTask = 2 fmt.Println(int(*pit)) fmt.Println(int(it)) task = pit // illegal //task = id task.Run()} Since only *ID implements Run() method, *ID satisfies interface Runnable but ID does not. 12312running task id = 1 Empty interfaceinterface{} is empty interface. Because it has no methods, all types satisfy the empty interface. Interface PitfallAn interface value with a nil dynamic value is NOT the same as a nil interface for any non-empty interfaces. If we assign nil to an empty interface variable, that variable is still equal to nil. If you want to keep the interface value consistent with its concrete value, please do not define a concrete value first then assign it to the interface value, but define the interface value directly (allocate a concrete value by new). 1234567891011func TestPitfall() { var pit *IntTask // zeroed as nil var run1 Runner = pit // warning: run1 is not nil var run2 Runner // zeroed as nil var run3 Runner = new(IntTask) var emptyInterface interface{} = nil fmt.Printf(&quot;run1 == nil ? %t\\n&quot;, run1 == nil) fmt.Printf(&quot;run2 == nil ? %t\\n&quot;, run2 == nil) fmt.Printf(&quot;run3 == nil ? %t\\n&quot;, run3 == nil) fmt.Printf(&quot;emptyInterface == nil ? %t\\n&quot;, emptyInterface == nil)} 1234run1 == nil ? falserun2 == nil ? truerun3 == nil ? falseemptyInterface == nil ? true Sortsort.Ints() and sort.Strings() only accept slice as argument. sort.Sort() provide a customizable method that requires the data type to be sorted should implement Len(), Swap() and Less(). 12var arr = [10]int{2, 3, 4, 6, 7, 9, 2, 3, 4, 5}sort.Ints(arr[:]) Type AssertionThe general form of type assertion is x.(T), while x is an interface to be tested (asserted), T can be a concrete type or another interface type. There are two usages of type assertion. T is a concrete type. The type assertion checks whether the concrete type of x is identical to T. T is an interface type. The type assertion checks whether the concrete type of x satisfies interface T. A successful type assertion returns the dynamic value in type T, and an optional assertion flag. A failed type assertion returns nil and flag false, if the statement only accepts one return value, it will cause a panic. 123456789101112131415161718192021func TestTypeAssert() { var itRunner Runner = new(IntTask) var ftRunner Runner = new(FloatTask) itRunner.Run() ftRunner.Run() // if without ok flag, such as pit2 := ftRunner.(*IntTask) // false assertions will cause panic pit, okInt := itRunner.(*IntTask) pit2, okInt2 := ftRunner.(*IntTask) pft, okFloat := ftRunner.(*FloatTask) pft2, okFloat2 := itRunner.(*FloatTask) fmt.Printf(&quot;assert itRunner to *IntTask: %t %T %p\\n&quot;, okInt, pit, pit) fmt.Printf(&quot;assert ftRunner to *IntTask: %t %T %p\\n&quot;, okInt2, pit2, pit2) fmt.Printf(&quot;assert ftRunner to *FloatTask: %t %T %p\\n&quot;, okFloat, pft, pft) fmt.Printf(&quot;assert itRunner to *FloatTask: %t %T %p\\n&quot;, okFloat2, pft2, pft2) *pit = 15640 *pft = 15.64 itRunner.Run() ftRunner.Run()} Type SwitchWe can use a type switch statement to replace an if-else chain of type assertions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func TestTypeSwitch() { var i int = 15640 var j float64 = 15.64 var k string = &quot;DS&quot; TypeSwitch1(i) TypeSwitch1(j) TypeSwitch1(k) fmt.Println(&quot;&quot;) TypeSwitch2(i) TypeSwitch2(j) TypeSwitch2(k) fmt.Println(&quot;&quot;) TypeSwitch3(i) TypeSwitch3(j) TypeSwitch3(k) fmt.Println(&quot;&quot;)}func TypeSwitch1(x interface{}) { switch x := x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch2(x interface{}) { switch x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch3(x interface{}) { switch x := x.(type) { case int, float64: fmt.Printf(&quot;Valid Type: %T\\n&quot;, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }} 1234567891011case int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected Typecase int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected TypeValid Type: intValid Type: float64Unexpected Type map, channel and reference in GoFirst of all, there is NO strict reference (alias) in Go, which means two variables refer (not point) to the same memeory location. In Go, everything is passed by value. But we can see that in Go map and channel can be passed by reference in function. This is because map and channel are pointers naturally, while do not look like pointers. For example, a map variable is actually a pointer to a runtime.hmap structure. By the way, channels act as FIFO queues. Closed and drained channelRead requests (not matter how many times) to a closed and drained channel always immediately returns a zero value. But we can examine receives on a closed and drained channel by using optional flag. 1234567891011func TestChannel() { channel := make(chan int, 10) close(channel) for { x, ok := &lt;- channel if !ok { break } fmt.Println(x) }} Or we can read elements from a channel by range, which will terminate the loop after reading the last element in a closed channel. 12345678910func TestChannel() { channel := make(chan int, 10) channel &lt;- 1 channel &lt;- 2 channel &lt;- 3 close(channel) for x := range channel { fmt.Println(x) }} Unidirectional channel typeschan&lt;- T: send-only channel; &lt;-chan T: receive-only channel. They can be used in function arguments to restrict the opertions to channels. Conversions from bidirectional channel to unidirectional channel types are permitted in any assignment. But there is no going back. nil channelSend and receive operations on a nil channel block forever. selectIn select, each case specifies a communication (a send or receive operation on some channel) and an associated block of statements. If there is only one runnable case, execute that case. If there is multiple runnable cases, randomly execute one of them. If there is no runnable cases, block. The default case in a select is run if no other case is ready. We can use select and a closed channel to terminate goroutines politely. Terminate a goroutineFirst, there is no way for one goroutine to terminate another directly. If we want to terminate a goroutine, we should send a “signal” to that goroutine and let it handles the signal by executing return. This signal can be implemented by a closed and drained channel. Because each receive operations to a closed and drained channel always immediately returns a zero value. It sounds great, right? But the problem is that if a goroutine is blocked, it cannot notice the signal at the same time. Thus, we need to ensure two things: If this routine may be blocked by other methods (listener.Accept(), etc), unblock these methods in Close(), for example, by listener.Close(). If this routine may be blocked by channel operations, always wrap every channel operation with a select-done structure. In other words, every channel operation should have a done case in parallel. 1234567891011121314151617181920212223242526272829var done = make(chan bool) // always emptyvar workChan = make(chan int, 10) // a buffered channel storing datafunc Close() { // broadcast termination signal close(done)}func sampleRoutine() { // ... select { case workChan &lt;- data: // do some non-blocking tasks case &lt;-done: return } // ...}func sampleRoutine2() { // ... select { default: // do some non-blocking tasks case &lt;-done: return } // ...} If we use for range to receive data from a channel in a goroutine function, which makes it hard to receive the termination signal, it can be rewritten by for{} and select. 123456789101112131415161718192021func sampleForRange() { // terminate loop automatically when workChan is closed and drained // cannot receive for res := range workChan { // ... }}func sampleForSelect() { for { select { case res, ok := &lt;-workChan: if !ok { // workChan is closed and drained return } // ... case &lt;-done: return } }} An ingenious example of decoupling on channel operation12345678910111213141516171819202122// work routine pulls integers from input channel// squares them and pushes results to output channelfunc (sq *SquarerImpl) work() { var toPush int dummy := make(chan int) pushOn := dummy pullOn := sq.input for { select { case unsquared := &lt;-pullOn: toPush = unsquared * unsquared pushOn = sq.output pullOn = nil case pushOn &lt;- toPush: pushOn = dummy pullOn = sq.input case &lt;-sq.close: sq.closed &lt;- true return } }} The constant generator iotaIn a const declaration, the value of iota begins at zero and increments by one for each item in the sequence. 1234567891011121314151617181920const ( zero = iota // 0 one // 1 two // 2 three // 3 four // 4)const ( first = 1 + iota // 1 second // 2 third // 3)const ( _ = 1 &lt;&lt; (10 * iota) KB // 1024 MB // 1024 * 1024 GB // 1024 * 1024 * 1024) Asynchronous Request Implementation12345type Request struct { reqType ReqType retChan chan interface{} reqBody []interface{}} Remove the first element of a sliceIt also applies on slices with length of 1. 1slice = slice[1:] json.Marshaljson.Marshal(v) takes a memory object (argument type interface{}) and return its json encoding. In network programming, it can conveniently convert a user-defined object into json payload of the packet. Flexible array members in a structureGo allows us to define flexible array members (slices) in structures. Different from C, we can define any number of slices at any places in a structure. 123456789101112131415type Struct1 struct { i int body []interface{}}type Struct2 struct { body []interface{}}type Struct3 struct { i int body1 []interface{} body2 []interface{} j int} Pop from a slices = s[1:]. It removes the first element of s. Note that when using this syntax, the length of s can be 1 or greater but cannot be 0. 12345678func TestSlicePop() { s := make([]int, 1) s[0] = 16540 s = s[1:] // remove the first element fmt.Println(len(s)) // print 0 s1 := make([]int, 0) s1 = s1[1:] // ERROR!} Delete from a mapDeleting a non-existing key from a map through delete() makes no effect. 12345678func TestMapDelete() { hashmap := make(map[int]int) hashmap[1] = 1 delete(hashmap, 0) for k, v := range hashmap { fmt.Printf(&quot;[%d, %d]\\n&quot;, k, v) }} 1[1, 1] Constants in GoGo does NOT support constant members in structures or constant structures. Implement timing events by tickerWe can create a ticker through time.NewTicker(interval), which generates ticks in its channel ticker.C at specified time intervals (obviously, the size of channel C is one. We do not want ticks to be accumulated). We can place the handling functions of timing events and other events in a for-select block, so that timing events will not affect the execution of normal events. Note that Stop() will stop sending ticks to the channel C but will not close it, to prevent a closed drained channel issue. 123456789101112func TestTicker() { ticker := time.NewTicker(10 * time.Second) //ticker.Stop() for { select { case t := &lt;-ticker.C: // timing event fmt.Println(t) // case e := &lt;-normalEventChan: } }} Implicit type conversions and implicit numeric conversionsGo does not allow implicit type conversions, and does not allow implicit numeric conversions except numeric conversions across constants. 12345678910111213141516171819202122232425262728func TestType() { var i int = 10 var j int64 = 10 var k int = 10 // 1/10 == 0 =&gt; 0.0 var p float64 = 1 / 10 // 1.0/10 =&gt; 1.0/10.0 =&gt; 0.1 var q float64 = 1.0 / 10 // illegal // var m float64 = 1.0 / i _ = j // to keep compiler happy // mismatched types // j = i // mismatched types /* if i == j { fmt.Println(&quot;i == j&quot;) } */ if i == k { fmt.Println(&quot;i == k&quot;) } fmt.Println(p) fmt.Println(q) // Go does not support implicit numeric conversion // p = i / k} 123i == k00.1","link":"/2021/12/22/Go-Programming-Tips/"},{"title":"Java Programming Tips","text":"Convert char to int12char c = '9';int i = Character.getNumericValue(c); 12char c = '9';int i = c - '0'; Add zeros at the beginning of a number12int i = 640;System.out.printf(&quot;%05d\\n&quot;, i); 100640 Fill an arrayUse Arrays.fill(array, val) to assign values to an array. 123int[] a = new int[10];Arrays.fill(a, 7);System.out.println(Arrays.toString(a)); 1[7, 7, 7, 7, 7, 7, 7, 7, 7, 7] Convert between string and char array123char[] arr = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};String s = new String(arr);char[] arr2 = s.toCharArray(); Default initialization of an array in JavaEverything in a Java program not explicitly set to something by the programmer, is initialized to a zero value. For references (anything that holds an object) that is null. For int/short/byte/long that is a 0. For float/double that is a 0.0 For booleans that is a false. For char that is the null character '\\u0000' (whose decimal equivalent is 0). Reverse a List1Collections.reverse(list); Create a List from an arrayTake the return of Array.asList() as the parameter of ArrayList constructor. 12int[] array = new int[10];ArrayList&lt;Integer&gt; arraylIST = new ArrayList&lt;&gt;(Arrays.asList(array)); Sort Primitive array: Arrays.sort(arr) Object array: Arrays.sort(integerArr, comparator) List: Collections.sort(list, comparator) 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Traverse a mapUse Map.Entry or HashMap.Entry. 1234HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();for (HashMap.Entry&lt;Integer, Integer&gt; e:hashMap.entrySet()) { // do something} isLetter() and isAlphabetic()isLetter() and isAlphabetic() are two methods of Character. The difference between them is: isAlphabetic() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER &amp;&amp; LETTER_NUMBER. isLetter() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER. The point is that isLetter() will return false given a letter number. For example, roman numeral five (the letter looks like “V”). Certainly, for the English language, the distinction makes no difference. Use Deque over Stack for LIFO stacksWe should use Deque rather than Stack for LIFO stacks. 12Deque&lt;Integer&gt; dstack = new ArrayDeque&lt;&gt;();Stack&lt;Integer&gt; sstack = new Stack&lt;&gt;(); // not recommended There are many reasons to prefer Deque: Deque is an interface but Stack is a class. So using Deque brings us more flexibility for future extension. Stack is synchronized but Deque is not thread-safe. In the case of no need to ensure thread safety, Deque is more efficient. Deque iterates elements from top to bottom. Stack iterates elements from bottom to top. Most important: with Stack, we can access/insert/remove arbitrary elements in the LIFO stack by indexes, stack.get(index); stack.add(index, e); stack.remove(index), which breaks the LIFO rule. Although Deque does not absolutely obey the LIFO rule, it can only access/insert/remove the first/last element in the LIFO stack. Print multi-dimensional arrays12System.out.println(Arrays.toString(arr)); // print a 1D arraySystem.out.println(Arrays.deepToString(marr)); // print a multi-dimensional array Get ceiling/floor value of a number12double ceilingValue = Math.ceil(3.1); // 4.0double floorValue = Math.floor(3.1); // 3.0 Note that these twoMath functions return double. Or if we need to get the ceiling value of a fraction X/Y, we can also do as the following: 1int res = (X + Y - 1) / Y; Sort an array/list Primitive array int[]: Arrays.sort Objective array Integer[]: Arrays.sort and optional comparator Objective list List&lt;Integer&gt;: Collections.sort and optional comparator 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Common time complexity calculation$$\\sum_{1}^{n}{k^2}=\\frac{1}{n}{n(n+1)(2n+1)}=O(n^3)\\\\sum_{1}^{n}{k^3}=(\\frac{1}{2}{n(n+1)})^2=O(n^4)$$ String manipulation1234StringBuilder builder1 = new StringBuilder(&quot;abcdefg&quot;);// if we want to delete c and add it backbuilder1.deleteCharAt(2); // &quot;abdefg&quot;builder1.insert(2, 'c'); // &quot;abcdefg&quot;","link":"/2021/12/22/Java-Programming-Tips/"},{"title":"A Brief Introduction to Dynamic Programming","text":"Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. example 123456789101112131415161718192021// recursionpublic int fib(int n) { if(n&lt;=1) return n; return fib(n-1)+fib(n-2);}// dynamic programmingpublic int fibDP(int n) { if (n&gt;1) { int fib=0, p1=1,p2=0; for (int i=2;i&lt;=n;i++) { fib = p1+p2; p2 = p1; p1 = fib; } return fib; } else if (n==1) { return 1; } else { return 0; }} Two pattern of solving DP problem: Tabulation: bottom up Memoization: top down","link":"/2021/12/22/A-Brief-Introduction-to-Dynamic-Programming/"},{"title":"OA Counting Analogous Array","text":"QuestionAn array is said to be analogous to the secret array if all of the following conditions are true:• The length of the array is equal to the length of the secret array.• Each integer in the array lies in the interval [lowerBound, upperBound].• The difference between each pair of consecutive integers of the array must be equal to the difference between the respective pair of consecutive integers in the secret array. In other words, let the secret array be [s[0], s[1],…, s[n-1]] and let the analogous array be [a[0], a[1],…, a[n-1]], then (a[i-1] - a[i]) must be equal to (s[i-1] - s[i]) for each i from 1 to n -1. Given the value of integers lowerBound and upperBound, inclusive, and the array of differences between each pair of consecutive integers of the secret array, find the number of arrays that are analogous to the secret array. If there is no array analogous to the secret array, return 0. For example:consecutiveDifference = [-2, -1, -2, 5]lowerBound = 3upperBound = 10 Note that none of the values is out of the bound. All possible analogous arrays are:[3, 5, 6, 8, 3][4, 6, 7, 9, 4][5, 7, 8, 10, 5] Tha answer is 3. Source: https://leetcode.com/discuss/interview-question/1332322/amazon-online-assessment-july-2021-secret-array Solution123456789101112131415161718public static int countAnalogousArrays(int[] consecutiveDifference, int lowerBound, int upperBound) { // parameter validation if (consecutiveDifference == null || consecutiveDifference.length &lt; 1 || lowerBound &gt; upperBound) { return 0; } int delta = 0, maxDelta = 0, minDelta = 0; for (int i = 0; i &lt; consecutiveDifference.length; i++) { delta += consecutiveDifference[i]; maxDelta = Math.max(maxDelta, delta); minDelta = Math.min(minDelta, delta); } int maxDiff = maxDelta - minDelta, boundGap = upperBound - lowerBound; // max difference exceeds bound gap if (maxDiff &gt; boundGap) { return 0; } return boundGap - maxDiff;}","link":"/2021/12/29/OA-Counting-Analogous-Array/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Array","slug":"Array","link":"/tags/Array/"}],"categories":[{"name":"C - K&amp;R","slug":"C-K-R","link":"/categories/C-K-R/"},{"name":"Programming Tips","slug":"Programming-Tips","link":"/categories/Programming-Tips/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}