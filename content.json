{"pages":[],"posts":[{"title":"A Brief Introduction to Dynamic Programming","text":"Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. example 123456789101112131415161718192021// recursionpublic int fib(int n) { if(n&lt;=1) return n; return fib(n-1)+fib(n-2);}// dynamic programmingpublic int fibDP(int n) { if (n&gt;1) { int fib=0, p1=1,p2=0; for (int i=2;i&lt;=n;i++) { fib = p1+p2; p2 = p1; p1 = fib; } return fib; } else if (n==1) { return 1; } else { return 0; }} Two pattern of solving DP problem: Tabulation: bottom up Memoization: top down","link":"/2021/12/22/A-Brief-Introduction-to-Dynamic-Programming/"},{"title":"Java Programming Tips","text":"Convert char to int12char c = '9';int i = Character.getNumericValue(c); 12char c = '9';int i = c - '0'; Add zeros at the beginning of a number12int i = 640;System.out.printf(&quot;%05d\\n&quot;, i); 100640 Fill an arrayUse Arrays.fill(array, val) to assign values to an array. 123int[] a = new int[10];Arrays.fill(a, 7);System.out.println(Arrays.toString(a)); 1[7, 7, 7, 7, 7, 7, 7, 7, 7, 7] Convert between string and char array123char[] arr = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};String s = new String(arr);char[] arr2 = s.toCharArray(); Convert integer to string123String s1 = String.valueOf(i);String s2 = Integer.toString(i, 10); // radix = 10String s3 = String.format(&quot;%d&quot;, i); Default initialization of an array in JavaEverything in a Java program not explicitly set to something by the programmer, is initialized to a zero value. For references (anything that holds an object) that is null. For int/short/byte/long that is a 0. For float/double that is a 0.0 For booleans that is a false. For char that is the null character '\\u0000' (whose decimal equivalent is 0). Reverse a List1Collections.reverse(list); Create a List from an arrayTake the return of Array.asList() as the parameter of ArrayList constructor. 12int[] array = new int[10];ArrayList&lt;Integer&gt; arraylIST = new ArrayList&lt;&gt;(Arrays.asList(array)); Sort Primitive array: Arrays.sort(arr) Object array: Arrays.sort(integerArr, comparator) List: Collections.sort(list, comparator) 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Traverse a mapUse Map.Entry or HashMap.Entry. 1234HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();for (HashMap.Entry&lt;Integer, Integer&gt; e:hashMap.entrySet()) { // do something} isLetter() and isAlphabetic()isLetter() and isAlphabetic() are two methods of Character. The difference between them is: isAlphabetic() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER &amp;&amp; LETTER_NUMBER. isLetter() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER. The point is that isLetter() will return false given a letter number. For example, roman numeral five (the letter looks like “V”). Certainly, for the English language, the distinction makes no difference. Use Deque over Stack for LIFO stacksWe should use Deque rather than Stack for LIFO stacks. 12Deque&lt;Integer&gt; dstack = new ArrayDeque&lt;&gt;();Stack&lt;Integer&gt; sstack = new Stack&lt;&gt;(); // not recommended There are many reasons to prefer Deque: Deque is an interface but Stack is a class. So using Deque brings us more flexibility for future extension. Stack is synchronized but Deque is not thread-safe. In the case of no need to ensure thread safety, Deque is more efficient. Deque iterates elements from top to bottom. Stack iterates elements from bottom to top. Most important: with Stack, we can access/insert/remove arbitrary elements in the LIFO stack by indexes, stack.get(index); stack.add(index, e); stack.remove(index), which breaks the LIFO rule. Although Deque does not absolutely obey the LIFO rule, it can only access/insert/remove the first/last element in the LIFO stack. Print multi-dimensional arrays12System.out.println(Arrays.toString(arr)); // print a 1D arraySystem.out.println(Arrays.deepToString(marr)); // print a multi-dimensional array Get ceiling/floor value of a number12double ceilingValue = Math.ceil(3.1); // 4.0double floorValue = Math.floor(3.1); // 3.0 Note that these twoMath functions return double. Or if we need to get the ceiling value of a fraction X/Y, we can also do as the following: 1int res = (X + Y - 1) / Y; Sort an array/list Primitive array int[]: Arrays.sort Objective array Integer[]: Arrays.sort and optional comparator Objective list List&lt;Integer&gt;: Collections.sort and optional comparator 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Common time complexity calculation$$\\sum_{1}^{n}{k^2}=\\frac{1}{n}{n(n+1)(2n+1)}=O(n^3)\\\\sum_{1}^{n}{k^3}=(\\frac{1}{2}{n(n+1)})^2=O(n^4)$$ String manipulation1234StringBuilder builder1 = new StringBuilder(&quot;abcdefg&quot;);// if we want to delete c and add it backbuilder1.deleteCharAt(2); // &quot;abdefg&quot;builder1.insert(2, 'c'); // &quot;abcdefg&quot; toCharArray() and getBytes()toCharArray() is better if we are not dealing with characters outside of the Unicode BMP, which are encoded as two surrogate characters. getBytes() needs to specify encoding, which is prone to mistakes. Also, toCharArray() is faster because for Java 7 and newer, a String object contains a char array internally. toCharArray() just need to complete a copy operation. Integer object comparisonFor two Integer objects, == compares their references while &lt; and &gt; compare their values. To examinate whether they have the same value, we should use equals() or unbox them by intValue(). And, it is safe to use comparison operators (==, &lt;, &gt;) for comparing values between an int and an Integer object. 1234567Integer i1 = new Integer(15640);Integer i2 = new Integer(15640);Integer i3 = new Integer(15440);System.out.printf(&quot;i1 == i2 : %b\\n&quot; + &quot;i1.value == i2.value : %b\\n&quot; + &quot;i1.equals(i2) : %b\\n&quot; + &quot;i2 &gt; i3 : %b\\n&quot;, i1 == i2, i1.intValue() == i2.intValue(), i1.equals(i2), i2 &gt; i3); 1234i1 == i2 : falsei1.value == i2.value : truei1.equals(i2) : truei2 &gt; i3 : true substring()substring(beginIndex, endIndex) returns the substring in [beginIndex, endIndex). And it is safe for beginIndex == endIndex == 0 or length. 123String s = &quot;hello&quot;;System.out.println(s.substring(0, 0)); // return &quot;&quot;System.out.println(s.substring(s.length(), s.length())); // return &quot;&quot; indexOf()s.indexOf(pattern, fromIndex) returns the first index of given pattern from fromIndex (inclusive). If such pattern does not exist, it returns -1.","link":"/2021/12/22/Java-Programming-Tips/"},{"title":"Common Algorithm Implementation Templates","text":"Traverse an array by groups123456for (int i = 0; i &lt; arr.length; i += interval) { for (int j = i; j &lt; i + interval &amp;&amp; j &lt; arr.length; j++) { // do something } // do something}","link":"/2022/01/05/Common-Algorithm-Implementation-Templates/"},{"title":"LeetCode 1048. Longest String Chain","text":"QuestionYou are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;, while &quot;cba&quot; is not a predecessor of &quot;bcad&quot;. A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1. Return the length of the longest possible word chain with words chosen from the given list of words. Example 1: 123Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]Output: 4Explanation: One of the longest word chains is [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]. Example 2: 123Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]Output: 5Explanation: All the words can be put in a word chain [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;]. Example 3: 1234Input: words = [&quot;abcd&quot;,&quot;dbqca&quot;]Output: 1Explanation: The trivial word chain [&quot;abcd&quot;] is one of the longest word chains.[&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed. Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 16 words[i] only consists of lowercase English letters. Source: https://leetcode.com/problems/longest-string-chain/ SolutionBottom-Up DP For words, the length of longest string chain that ends with word equals $max(pre_0(word),pre_1(word),…,pre_{l-1}(word))+1$ 1234567891011121314151617181920212223242526272829303132public int longestStrChain(String[] words) { // parameter validation if (words == null || words.length &lt; 1) { return 0; } // s -&gt; max length of string chain ending with s Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); // sort words by length of each word Arrays.sort(words, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }); int len = words.length; int maxLen = 0; for (int i = 0; i &lt; len; i++) { int currLen = 1; StringBuilder temp = new StringBuilder(words[i]); for (int k = 0; k &lt; words[i].length(); k++) { char c = temp.charAt(k); temp.deleteCharAt(k); String predecessor = temp.toString(); int prevLen = cache.getOrDefault(predecessor, 0); currLen = Math.max(currLen, prevLen + 1); temp.insert(k, c); // restore the change } cache.put(words[i], currLen); maxLen = Math.max(maxLen, currLen); } return maxLen;}","link":"/2021/12/30/LeetCode-1048-Longest-String-Chain/"},{"title":"Go Programming Tips","text":"Add 0x prefix when printing hex numbersUse %#x placeholder. 12345func TestPrintHex() { var i int = 0x123456 fmt.Printf(&quot;%x\\n&quot;, i) fmt.Printf(&quot;%#x\\n&quot;, i)} 121234560x123456 Print the type of a variable123fmt.Printf(&quot;%T\\n&quot;, i)fmt.Println(reflect.Typeof(i))fmt.Prinft(&quot;%s\\n&quot;, reflect.Typeof(i).String()) Get random numbersIntn() returns the next integer in the current random sequence. UnixNano() returns the number of nanoseconds elapsed since January 1, 1970 UTC. And the result of UnixNano() does not depend on the location associated with t. We only have to set the seed once. But before we set the seed, rand will use the default seed. For example, the first call of Intn(100) always returns 81 without setting the seed. 12rand.Seed(time.Now().UnixNano())fmt.Println(rand.Intn(100)) Temporary variables in if-else blockIn Go, we can define variables in if-else condition statement. The scope of these temporary variables is limited within if-else block. 12345if v, p := math.Sqrt(float64(sum)), math.Sin(float64(sum)); v &lt; 10 &amp;&amp; p &lt; 0.5 { fmt.Println(&quot;True&quot;)} else { fmt.Println(v, p)} switchIn Go, the execution does not fall through the switch structure. Switch cases evaluate cases from top to bottom, stopping when a case succeeds. Also, if we want to take the same action on multiple cases, we can write case content1, content2:. In the following example, although without any break, the control flow jumps out of the switch block after executing the first case. 123456789var i int = 15640switch {case i &gt; 1: fmt.Println(i)case i &gt; 2: fmt.Println(i)case i &gt; 99999: fmt.Println(&quot;false&quot;)} 115640 SliceSlices share the same underlying memory with the original array. The type of slice is []T. len() returns the number of elements a slice contains. cap() returns the number of elements in the underlying array, counting from the first element in the slice. append(slice, e1, e2, ...) overwrites the elements in the underlying array if slice has enough capacity to contain these elements. Otherwise, it returns a new allocated slice and keeps the underlying array intact. 123456789101112131415161718192021222324func TestSlice() { var arr [5]int = [5]int{0, 1, 2, 3, 4} slice1 := arr[0:4] slice2 := arr[1:4] fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(arr).String(), len(arr), cap(arr)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice1).String(), len(slice1), cap(slice1)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice2).String(), len(slice2), cap(slice2)) slice1[0] = 9 fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2, &quot;\\n&quot;) // Test slice append slice3 := append(slice2, 8) // change the underlying array slice4 := append(slice2, 7, 6) // return a new allocated slice fmt.Println(arr, &amp;arr[0], cap(arr)) fmt.Println(slice1, &amp;slice1[0], cap(slice1)) fmt.Println(slice2, &amp;slice2[0], cap(slice2)) fmt.Println(slice3, &amp;slice3[0], cap(slice3)) fmt.Println(slice4, &amp;slice4[0], cap(slice4))} 123456789101112131415[0 1 2 3 4][0 1 2 3][1 2 3]type: [5]int, len: 5, cap: 5type: []int, len: 4, cap: 5type: []int, len: 3, cap: 4[9 1 2 3 4][9 1 2 3][1 2 3] [9 1 2 3 8] 0xc000018270 5[9 1 2 3] 0xc000018270 5[1 2 3] 0xc000018278 4[1 2 3 8] 0xc000018278 4[1 2 3 7 6] 0xc00001e080 8 Variable Length ArrayGo only allows constants to be used as array size. To create an array whose size is defined by a variabl, we can use make([]T, length). It creates an underlying array with size of length and returns a slice of it. 12345678910111213const conLen = 8func TestVLA(length int) { var l int = 5 // illegal //var arr0 [len]int //var arr1 [l]int var arr2 = make([]int, l) var arr3 = make([]int, length) var arr4 [conLen]int // do something} String comparisonIn Go, we can compare strings by using comparison operators (==, &lt;, &gt;, etc) or by strings.Compare(s1, s2). File naming conventionsnake_case is the convention across the most of the standard library and most third party libraries for Go. deferdefer FunctionCall() defers the execution of FunctionCall() until the surrounding function (the parent function call of FunctionCall()) returns. Multiple deferred calls are stacked, so that they will be callled in a LIFO order. 123456func TestDefer() { for i:= 0; i &lt; 5; i++ { defer fmt.Println(&quot;deferred call&quot;, i) } fmt.Println(&quot;ready to return&quot;)} 123456ready to returndeferred call 4deferred call 3deferred call 2deferred call 1deferred call 0 HashmapIn Go, we can declaring a hashmap by using key word map. map declares a non-thread-safe hashmap. Create a hash map: hashmap := make(map[string]int), string is key type and int is value type. Insert a key-value pair: hashmap[key] = value. Delete a key-value pair: delete(hashmap, key). Check whether a key exists: v, ok := hashmap[key]. If the key exists, ok == true. Otherwise, v equals to the zero value of the value type, ok == false. Traverse the hashmap: for k, v := range hashmap {// do someting} Difference between make and new make returns a value of T; new returns a value of *T. make returns an initialized value; new returns a zeroed value. make can only create and initialize slices, maps and channels; new can allocate zeroed memory for any types. Take hashmap as an example. Since we need to initialize structure of hashmap itself before using it (it means that we cannot just zero the hashmap memory), we have to create a hashmap by hashmap := make(map[string]int) or hashmap := map[string]int{}. Format go files recursively1go fmt path/... MethodIn Go, methods take either a value or a pointer as the receiver when they are called. Go interprets s.Print() as (&amp;s).Print(), ps.SwapPrint() as (*ps).SwapPrint(). But this is just syntactic sugar. Also, we cannot define new methods for existing types in another package (including built-in types, such as int, map). But it is fine to define a normal function that takes a non-local-package type argument. Or we can define our own alias for that type in current package type Alias ExistingTypeName, or define a wrapper structure containing that type type NewStruct struct {n ExistingTypeName} 1234567891011121314151617181920212223type MyStruct struct { x int y int}func (ps *MyStruct) Print() { fmt.Printf(&quot;(%d, %d)\\n&quot;, ps.x, ps.y)}func (s MyStruct) SwapPrint() { fmt.Printf(&quot;(%d, %d)\\n&quot;, s.y, s.x)}func TestMethod() { ps := new(MyStruct) ps.x = 12 ps.y = 24 s := MyStruct{12, 24} ps.Print() ps.SwapPrint() s.Print() s.SwapPrint()} InterfaceAny concrete types that implement all methods of a interface type satisfy implicitly that interface type. In other words, a interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. Note that T and *T are different when it comes to the relationship between interfaces and concrete types. And we cannot define methods for types under another package. 12345678910111213141516171819202122232425type IntTask inttype FloatTask float64type Runner interface { Run()}func (pit *IntTask) Run() { fmt.Printf(&quot;running task id = %d\\n&quot;, int(*pit))}func TestInterface() { var task Runner var pit *IntTask = new(IntTask) *pit = 1 var it IntTask = 2 fmt.Println(int(*pit)) fmt.Println(int(it)) task = pit // illegal //task = id task.Run()} Since only *ID implements Run() method, *ID satisfies interface Runnable but ID does not. 12312running task id = 1 Empty interfaceinterface{} is empty interface. Because it has no methods, all types satisfy the empty interface. Interface PitfallAn interface value with a nil dynamic value is NOT the same as a nil interface for any non-empty interfaces. If we assign nil to an empty interface variable, that variable is still equal to nil. If you want to keep the interface value consistent with its concrete value, please do not define a concrete value first then assign it to the interface value, but define the interface value directly (allocate a concrete value by new). 1234567891011func TestPitfall() { var pit *IntTask // zeroed as nil var run1 Runner = pit // warning: run1 is not nil var run2 Runner // zeroed as nil var run3 Runner = new(IntTask) var emptyInterface interface{} = nil fmt.Printf(&quot;run1 == nil ? %t\\n&quot;, run1 == nil) fmt.Printf(&quot;run2 == nil ? %t\\n&quot;, run2 == nil) fmt.Printf(&quot;run3 == nil ? %t\\n&quot;, run3 == nil) fmt.Printf(&quot;emptyInterface == nil ? %t\\n&quot;, emptyInterface == nil)} 1234run1 == nil ? falserun2 == nil ? truerun3 == nil ? falseemptyInterface == nil ? true Sortsort.Ints() and sort.Strings() only accept slice as argument. sort.Sort() provide a customizable method that requires the data type to be sorted should implement Len(), Swap() and Less(). 12var arr = [10]int{2, 3, 4, 6, 7, 9, 2, 3, 4, 5}sort.Ints(arr[:]) Type AssertionThe general form of type assertion is x.(T), while x is an interface to be tested (asserted), T can be a concrete type or another interface type. There are two usages of type assertion. T is a concrete type. The type assertion checks whether the concrete type of x is identical to T. T is an interface type. The type assertion checks whether the concrete type of x satisfies interface T. A successful type assertion returns the dynamic value in type T, and an optional assertion flag. A failed type assertion returns nil and flag false, if the statement only accepts one return value, it will cause a panic. 123456789101112131415161718192021func TestTypeAssert() { var itRunner Runner = new(IntTask) var ftRunner Runner = new(FloatTask) itRunner.Run() ftRunner.Run() // if without ok flag, such as pit2 := ftRunner.(*IntTask) // false assertions will cause panic pit, okInt := itRunner.(*IntTask) pit2, okInt2 := ftRunner.(*IntTask) pft, okFloat := ftRunner.(*FloatTask) pft2, okFloat2 := itRunner.(*FloatTask) fmt.Printf(&quot;assert itRunner to *IntTask: %t %T %p\\n&quot;, okInt, pit, pit) fmt.Printf(&quot;assert ftRunner to *IntTask: %t %T %p\\n&quot;, okInt2, pit2, pit2) fmt.Printf(&quot;assert ftRunner to *FloatTask: %t %T %p\\n&quot;, okFloat, pft, pft) fmt.Printf(&quot;assert itRunner to *FloatTask: %t %T %p\\n&quot;, okFloat2, pft2, pft2) *pit = 15640 *pft = 15.64 itRunner.Run() ftRunner.Run()} Type SwitchWe can use a type switch statement to replace an if-else chain of type assertions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func TestTypeSwitch() { var i int = 15640 var j float64 = 15.64 var k string = &quot;DS&quot; TypeSwitch1(i) TypeSwitch1(j) TypeSwitch1(k) fmt.Println(&quot;&quot;) TypeSwitch2(i) TypeSwitch2(j) TypeSwitch2(k) fmt.Println(&quot;&quot;) TypeSwitch3(i) TypeSwitch3(j) TypeSwitch3(k) fmt.Println(&quot;&quot;)}func TypeSwitch1(x interface{}) { switch x := x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch2(x interface{}) { switch x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch3(x interface{}) { switch x := x.(type) { case int, float64: fmt.Printf(&quot;Valid Type: %T\\n&quot;, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }} 1234567891011case int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected Typecase int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected TypeValid Type: intValid Type: float64Unexpected Type map, channel and reference in GoFirst of all, there is NO strict reference (alias) in Go, which means two variables refer (not point) to the same memeory location. In Go, everything is passed by value. But we can see that in Go map and channel can be passed by reference in function. This is because map and channel are pointers naturally, while do not look like pointers. For example, a map variable is actually a pointer to a runtime.hmap structure. By the way, channels act as FIFO queues. Closed and drained channelRead requests (not matter how many times) to a closed and drained channel always immediately returns a zero value. But we can examine receives on a closed and drained channel by using optional flag. 1234567891011func TestChannel() { channel := make(chan int, 10) close(channel) for { x, ok := &lt;- channel if !ok { break } fmt.Println(x) }} Or we can read elements from a channel by range, which will terminate the loop after reading the last element in a closed channel. 12345678910func TestChannel() { channel := make(chan int, 10) channel &lt;- 1 channel &lt;- 2 channel &lt;- 3 close(channel) for x := range channel { fmt.Println(x) }} Unidirectional channel typeschan&lt;- T: send-only channel; &lt;-chan T: receive-only channel. They can be used in function arguments to restrict the opertions to channels. Conversions from bidirectional channel to unidirectional channel types are permitted in any assignment. But there is no going back. nil channelSend and receive operations on a nil channel block forever. selectIn select, each case specifies a communication (a send or receive operation on some channel) and an associated block of statements. If there is only one runnable case, execute that case. If there is multiple runnable cases, randomly execute one of them. If there is no runnable cases, block. The default case in a select is run if no other case is ready. We can use select and a closed channel to terminate goroutines politely. Terminate a goroutineFirst, there is no way for one goroutine to terminate another directly. If we want to terminate a goroutine, we should send a “signal” to that goroutine and let it handles the signal by executing return. This signal can be implemented by a closed and drained channel. Because each receive operations to a closed and drained channel always immediately returns a zero value. It sounds great, right? But the problem is that if a goroutine is blocked, it cannot notice the signal at the same time. Thus, we need to ensure two things: If this routine may be blocked by other methods (listener.Accept(), etc), unblock these methods in Close(), for example, by listener.Close(). If this routine may be blocked by channel operations, always wrap every channel operation with a select-done structure. In other words, every channel operation should have a done case in parallel. 1234567891011121314151617181920212223242526272829var done = make(chan bool) // always emptyvar workChan = make(chan int, 10) // a buffered channel storing datafunc Close() { // broadcast termination signal close(done)}func sampleRoutine() { // ... select { case workChan &lt;- data: // do some non-blocking tasks case &lt;-done: return } // ...}func sampleRoutine2() { // ... select { default: // do some non-blocking tasks case &lt;-done: return } // ...} If we use for range to receive data from a channel in a goroutine function, which makes it hard to receive the termination signal, it can be rewritten by for{} and select. 123456789101112131415161718192021func sampleForRange() { // terminate loop automatically when workChan is closed and drained // cannot receive for res := range workChan { // ... }}func sampleForSelect() { for { select { case res, ok := &lt;-workChan: if !ok { // workChan is closed and drained return } // ... case &lt;-done: return } }} An ingenious example of decoupling on channel operation12345678910111213141516171819202122// work routine pulls integers from input channel// squares them and pushes results to output channelfunc (sq *SquarerImpl) work() { var toPush int dummy := make(chan int) pushOn := dummy pullOn := sq.input for { select { case unsquared := &lt;-pullOn: toPush = unsquared * unsquared pushOn = sq.output pullOn = nil case pushOn &lt;- toPush: pushOn = dummy pullOn = sq.input case &lt;-sq.close: sq.closed &lt;- true return } }} The constant generator iotaIn a const declaration, the value of iota begins at zero and increments by one for each item in the sequence. 1234567891011121314151617181920const ( zero = iota // 0 one // 1 two // 2 three // 3 four // 4)const ( first = 1 + iota // 1 second // 2 third // 3)const ( _ = 1 &lt;&lt; (10 * iota) KB // 1024 MB // 1024 * 1024 GB // 1024 * 1024 * 1024) Asynchronous Request Implementation12345type Request struct { reqType ReqType retChan chan interface{} reqBody []interface{}} Remove the first element of a sliceIt also applies on slices with length of 1. 1slice = slice[1:] json.Marshaljson.Marshal(v) takes a memory object (argument type interface{}) and return its json encoding. In network programming, it can conveniently convert a user-defined object into json payload of the packet. Flexible array members in a structureGo allows us to define flexible array members (slices) in structures. Different from C, we can define any number of slices at any places in a structure. 123456789101112131415type Struct1 struct { i int body []interface{}}type Struct2 struct { body []interface{}}type Struct3 struct { i int body1 []interface{} body2 []interface{} j int} Pop from a slices = s[1:]. It removes the first element of s. Note that when using this syntax, the length of s can be 1 or greater but cannot be 0. 12345678func TestSlicePop() { s := make([]int, 1) s[0] = 16540 s = s[1:] // remove the first element fmt.Println(len(s)) // print 0 s1 := make([]int, 0) s1 = s1[1:] // ERROR!} Delete from a mapDeleting a non-existing key from a map through delete() makes no effect. 12345678func TestMapDelete() { hashmap := make(map[int]int) hashmap[1] = 1 delete(hashmap, 0) for k, v := range hashmap { fmt.Printf(&quot;[%d, %d]\\n&quot;, k, v) }} 1[1, 1] Constants in GoGo does NOT support constant members in structures or constant structures. Implement timing events by tickerWe can create a ticker through time.NewTicker(interval), which generates ticks in its channel ticker.C at specified time intervals (obviously, the size of channel C is one. We do not want ticks to be accumulated). We can place the handling functions of timing events and other events in a for-select block, so that timing events will not affect the execution of normal events. Note that Stop() will stop sending ticks to the channel C but will not close it, to prevent a closed drained channel issue. 123456789101112func TestTicker() { ticker := time.NewTicker(10 * time.Second) //ticker.Stop() for { select { case t := &lt;-ticker.C: // timing event fmt.Println(t) // case e := &lt;-normalEventChan: } }} Implicit type conversions and implicit numeric conversionsGo does not allow implicit type conversions, and does not allow implicit numeric conversions except numeric conversions across constants. 12345678910111213141516171819202122232425262728func TestType() { var i int = 10 var j int64 = 10 var k int = 10 // 1/10 == 0 =&gt; 0.0 var p float64 = 1 / 10 // 1.0/10 =&gt; 1.0/10.0 =&gt; 0.1 var q float64 = 1.0 / 10 // illegal // var m float64 = 1.0 / i _ = j // to keep compiler happy // mismatched types // j = i // mismatched types /* if i == j { fmt.Println(&quot;i == j&quot;) } */ if i == k { fmt.Println(&quot;i == k&quot;) } fmt.Println(p) fmt.Println(q) // Go does not support implicit numeric conversion // p = i / k} 123i == k00.1","link":"/2021/12/22/Go-Programming-Tips/"},{"title":"LeetCode 1335. Minimum Difficulty of a Job Schedule","text":"QuestionYou want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 &lt;= j &lt; i). You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day. You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i]. Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1. Example 1: 12345Input: jobDifficulty = [6,5,4,3,2,1], d = 2Output: 7Explanation: First day you can finish the first 5 jobs, total difficulty = 6.Second day you can finish the last job, total difficulty = 1.The difficulty of the schedule = 6 + 1 = 7 Example 2: 123Input: jobDifficulty = [9,9,9], d = 4Output: -1Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs. Example 3: 123Input: jobDifficulty = [1,1,1], d = 3Output: 3Explanation: The schedule is one job per day. total difficulty will be 3. Constraints: 1 &lt;= jobDifficulty.length &lt;= 300 0 &lt;= jobDifficulty[i] &lt;= 1000 1 &lt;= d &lt;= 10 Source: https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/ SolutionIn this problem, jobs are dependent so we can only complete jobs sequentially. For a day, we only need to consider the start job index m and the end job index n, which means on that day we complete all jobs between job m and job n (inclusive). cache[i][j] represents the minimum sum of difficulties when completing the first j+1 jobs in i+1 days. In the following code block, we traverse the start job index from high to low. It gets the max difficulty of jobs on that day more efficiently. 1234for (int k = j; k &gt;= i; k--) { dayMax = Math.max(dayMax, jobDifficulty[k]); cache[i][j] = Math.min(cache[i][j], cache[i - 1][k - 1] + dayMax);} 12345678910111213141516171819202122232425262728// bottom-up 2D DP, time complexity O(nnd), space complexity O(nd)public int minDifficulty(int[] jobDifficulty, int d) { // parameter validation if (d &lt; 1 || jobDifficulty == null || jobDifficulty.length &lt; 1 || jobDifficulty.length &lt; d) { return -1; } int n = jobDifficulty.length; // number of jobs // cache for DP // cache[i][j] represents the min sum of difficulties when completing jobs up to j job on i day int[][] cache = new int[d][n]; cache[0][0] = jobDifficulty[0]; for (int j = 1; j &lt; n; j++) { cache[0][j] = Math.max(cache[0][j - 1], jobDifficulty[j]); } for (int i = 1; i &lt; d; i++) { // only use a half of the cache because we must complete at least one job per day for (int j = i; j &lt; n; j++) { cache[i][j] = Integer.MAX_VALUE; int dayMax = Integer.MIN_VALUE; // k is the index of start job on i day for (int k = j; k &gt;= i; k--) { dayMax = Math.max(dayMax, jobDifficulty[k]); cache[i][j] = Math.min(cache[i][j], cache[i - 1][k - 1] + dayMax); } } } return cache[d - 1][n - 1];}","link":"/2022/01/08/LeetCode-1335-Minimum-Difficulty-of-a-Job-Schedule/"},{"title":"LeetCode 155. Min Stack","text":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Example 1: 12345678910111213141516Input[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]Output[null,null,null,null,-3,null,0,-2]ExplanationMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); // return -3minStack.pop();minStack.top(); // return 0minStack.getMin(); // return -2 Constraints: -231 &lt;= val &lt;= 231 - 1 Methods pop, top and getMin operations will always be called on non-empty stacks. At most 3 * 104 calls will be made to push, pop, top, and getMin. Source: https://leetcode.com/problems/min-stack/ SolutionWe use a monotonic stack to maintain potential min elements in the future. Monotonic data structures are very effective in solving max/min problems. This solution can be further optimized. For example, we can replace mins with an object stack that contains &lt;value, times&gt;, so that we can save space when there are many mins with the same value. 1234567891011121314151617181920212223242526272829303132333435363738394041public class MinStack { private Deque&lt;Integer&gt; stack; // stack of candidate minimums // only keep candidates that can be the min after a series of operations private Deque&lt;Integer&gt; mins; public MinStack() { this.stack = new ArrayDeque&lt;&gt;(); this.mins = new ArrayDeque&lt;&gt;(); } public void push(int val) { stack.push(val); if (mins.isEmpty()) { mins.push(val); } else if (val &lt;= mins.peek()) { mins.push(val); } } // @pre: stack is not empty public void pop() { if (stack.isEmpty()) { return; } int val = stack.pop(); if (val == mins.peek()) { mins.pop(); } } // @pre: stack is not empty public int top() { return stack.peek().intValue(); } // @pre: stack is not empty public int getMin() { return mins.peek(); }}","link":"/2022/01/09/LeetCode-155-Min-Stack/"},{"title":"LeetCode 134. Gas Station","text":"QuestionThere are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Example 1: 12345678910Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2: 123456789Input: gas = [2,3,4], cost = [3,4,3]Output: -1Explanation:You can't start at station 0 or 1, as there is not enough gas to travel to the next station.Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can't travel around the circuit once no matter where you start. Constraints: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 Source: https://leetcode.com/problems/gas-station/ SolutionWe can abstract this problem as following: Given a delta array int[] delta, find a routine that sequentially traverses the array and makes the sum of $\\delta$ always above or equal to zero during traversal, and return the start index of this routine. If there is no such routine, return -1. There are two critical properities, we will prove and explain them later: If $\\sum_{i=0}^{n-1}{\\delta_i} \\ge0$, there must be at least one valid routine. If $\\sum_{i=p}^{q}{\\delta_i} &lt;0$ and $\\delta_p \\ge0$, any indice between $p$ and $q$ (inclusive) are not the start index of a valid routine. According to these two properties, we just need to traverse the array twice, one for checking whether a solution exists, the other for finding the first solution. Proof for the first property (Mathematical induction): Proof for the second property (better to understand by intuition): Note that just from the sum of the whole delta array, we cannot determine the number of solutions. Multiple solutions may exist when the sum is zero or greater than zero. For example, [1, 2, 3, 4] and [1, -1, 1, -1]. These two properties can also be used on many other situations. 1234567891011121314151617181920212223// two-pass, can be merged into one passpublic int canCompleteCircuit(int[] gas, int[] cost) { int len = gas.length; int totalTank = 0; // check if there is a solution for (int i = 0; i &lt; len; i++) { totalTank += gas[i] - cost[i]; } if (totalTank &lt; 0) { return -1; } // if solution exists, find a solution int currTank = 0; int startIndex = 0; for (int i = 0; i &lt; len; i++) { currTank += gas[i] - cost[i]; if (currTank &lt; 0) { // set i+1 as the start station and reset tank to zero startIndex = i + 1; currTank = 0; } } return startIndex;}","link":"/2021/12/29/LeetCode-134-Gas-Station/"},{"title":"LeetCode 271. Encode and Decode String","text":"QuestionDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: 1234string encode(vector&lt;string&gt; strs) { // ... your code return encoded_string;} Machine 2 (receiver) has the function: 1234vector&lt;string&gt; decode(string s) { //... your code return strs;} So Machine 1 does: 1string encoded_string = encode(strs); and Machine 2 does: 1vector&lt;string&gt; strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. You are not allowed to solve the problem using any serialize methods (such as eval). Example 1: 1234567891011Input: dummy_input = [&quot;Hello&quot;,&quot;World&quot;]Output: [&quot;Hello&quot;,&quot;World&quot;]Explanation:Machine 1:Codec encoder = new Codec();String msg = encoder.encode(strs);Machine 1 ---msg---&gt; Machine 2Machine 2:Codec decoder = new Codec();String[] strs = decoder.decode(msg); Example 2: 12Input: dummy_input = [&quot;&quot;]Output: [&quot;&quot;] Constraints: 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] contains any possible characters out of 256 valid ASCII characters. Source: https://leetcode.com/problems/encode-and-decode-strings/ SolutionThe best solution is to add a header that represents the length of each string instead of using delimiter. Strings will be concatenated as header-payload-header-.... Note that we call toCharArray method rather than getBytes(). We do not care about the content of payload so that we do not need to encode/decode strings. Also, on some OA platforms, we may need to import desired character set manually. 123456789101112131415161718192021222324252627282930313233343536373839404142// encode a 32-bit integer to a char array, according to little endian// then convert the byte array into a stringprivate String int2string(int len) { char[] bytes = new char[4]; for (int i = 0; i &lt; 4; i++) { bytes[i] = (char) ((len &gt;&gt; (i * 8)) &amp; 0xff); } return new String(bytes);}// decode a 32-bit string to intprivate int string2int(String s) { char[] bytes = s.toCharArray(); int len = 0; for (int i = 0; i &lt; 4; i++) { len += ((int) (bytes[i])) &lt;&lt; (i * 8); } return len;}// Encodes a list of strings to a single string.public String encode(List&lt;String&gt; strs) { StringBuilder builder = new StringBuilder(); for (String str : strs) { builder.append(int2string(str.length())); builder.append(str); } return builder.toString();}// Decodes a single string to a list of strings.public List&lt;String&gt; decode(String s) { int i = 0; List&lt;String&gt; res = new ArrayList&lt;&gt;(); while (i &lt; s.length()) { int strLen = string2int(s.substring(i, i + 4)); i += 4; res.add(s.substring(i, i + strLen)); i += strLen; } return res;}","link":"/2021/12/30/LeetCode-271-Encode-and-Decode-String/"},{"title":"LeetCode 3. Longest Substring Without Repeating Characters","text":"QuestionGiven a string s, find the length of the longest substring without repeating characters. Example 1: 123Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: s = &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: s = &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Constraints: 0 &lt;= s.length &lt;= 5 * 104 s consists of English letters, digits, symbols and spaces Source: https://leetcode.com/problems/longest-substring-without-repeating-characters/ SolutionSliding window is an optimization for brutal force search. When searching substrings that satisfy certain conditions, we do not have to examine every substring. In some cases, we can end up some search paths early and try another direction, which is similar to pruning in DFS. Take the following string as an example. It is meaningless to check substrings that start with ‘a’, ‘b’, ‘c’ and the first ‘5’ because they will definitely include repeating ‘5’ if they have a larger or the same length. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// brutal force, O(n^2)public int lengthOfLongestSubstring0(String s) { int len = s.length(); int maxSubLen = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); // i, j are the left and right end (inclusive) of a substring for (int i = 0; i &lt; len; i++) { for (int j = i; j &lt; len; j++) { char c = s.charAt(j); if (set.contains(c)) { break; } else { set.add(c); maxSubLen = Math.max(maxSubLen, j - i + 1); } } set.clear(); } return maxSubLen;}// sliding window, O(n)public int lengthOfLongestSubstring1(String s) { int len = s.length(); int maxSubLen = 0; int left = 0, right = 0; // character -&gt; frequency in the current substring Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (left &lt; len &amp;&amp; right &lt; len) { char cright = s.charAt(right); while (map.getOrDefault(cright, 0) &gt; 0) { char cleft = s.charAt(left); map.put(cleft, map.get(cleft) - 1); left++; } map.put(cright, 1); maxSubLen = Math.max(maxSubLen, right - left + 1); right++; } return maxSubLen;}// optimized sliding window, O(n)public int lengthOfLongestSubstring2(String s) { int len = s.length(); int maxSubLen = 0; int left = 0, right = 0; // character -&gt; last index of this character Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (left &lt; len &amp;&amp; right &lt; len) { char cright = s.charAt(right); if (map.containsKey(cright)) { // when left end moving forward, we do not remove kv pairs from map // only if the last index of cright is within the range of current substring // we move left forward left = Math.max(left, map.get(cright) + 1); } map.put(cright, right); maxSubLen = Math.max(maxSubLen, right - left + 1); right++; } return maxSubLen;}","link":"/2022/01/09/LeetCode-3-Longest-Substring-Without-Repeating-Characters/"},{"title":"LeetCode 696. Count Binary Substrings","text":"QuestionGive a binary string s, return the number of non-empty substrings that have the same number of 0‘s and 1‘s, and all the 0‘s and all the 1‘s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: 12345Input: s = &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: 123Input: s = &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1's and 0's. Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either '0' or '1'. Source: https://leetcode.com/problems/count-binary-substrings/ SolutionRepresent the string as groups of continuous 1s and 0s. The question requires “substrings”, which greatly simplifies the solution since characters in a substring must be continuous in the original string. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// group// Time Complexity: O(N), Space Complexity: O(N)public int countBinarySubstrings(String s) { // parameter validation if (s == null || s.length() &lt; 1) { return 0; } int len = s.length(); int[] group = new int[len]; int lastGroupIndex = 0; group[0] = 1; // get 0,1 distribution // [3, 2, 4, 1] for &quot;1110011110&quot; for (int i = 1; i &lt; len; i++) { if (s.charAt(i - 1) != s.charAt(i)) { lastGroupIndex++; group[lastGroupIndex] = 1; } else { group[lastGroupIndex]++; } } int result = 0; for (int i = 1; i &lt;= lastGroupIndex; i++) { result += Math.min(group[i - 1], group[i]); } return result;}// space optimized// like Fibonacci sequence// Time Complexity: O(N), Space Complexity: O(1)public int countBinarySubstrings2(String s) { // parameter validation if (s == null || s.length() &lt; 1) { return 0; } int len = s.length(); int result = 0, lastGroupNum = 0, currGroupNum = 1; for (int i = 1; i &lt; len; i++) { if (s.charAt(i - 1) != s.charAt(i)) { // update result at the start of a new group result += Math.min(lastGroupNum, currGroupNum); lastGroupNum = currGroupNum; currGroupNum = 1; } else { currGroupNum++; } } // handle corner case result += Math.min(lastGroupNum, currGroupNum); return result;}","link":"/2021/12/29/LeetCode-696-Count-Binary-Substrings/"},{"title":"LeetCode 718. Maximum Length of Repeated Subarray","text":"QuestionGiven two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays. Example 1: 123Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3,2,1]. Example 2: 12Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]Output: 5 Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 100 Source: https://leetcode.com/problems/maximum-length-of-repeated-subarray/ SolutionThe key idea of the transition equation is that a long common string (array) must contain short common strings (arrays). Thus, a long common string can be grown from a short common string. We simplify the searching process by searching common prefix num[i:], so that we only need to move one end of the string (array). Also, common suffix has the same effect. 1234567891011121314151617181920// DP, prefixpublic int findLength(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int maxCommonLen = 0; // dp[i][j] is the max length of common prefix of nums1[i:] and nums2[j:] // elements on the redundant row and column are initialized to zero, simplify the implementation int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = len1 - 1; i &gt;= 0; i--) { for (int j = len2 - 1; j &gt;= 0; j--) { if (nums1[i] == nums2[j]) { dp[i][j] = dp[i + 1][j + 1] + 1; } else { dp[i][j] = 0; } maxCommonLen = Math.max(maxCommonLen, dp[i][j]); } } return maxCommonLen;}","link":"/2022/01/08/LeetCode-718-Maximum-Length-of-Repeated-Subarray/"},{"title":"OA Count Analogous Arrays","text":"QuestionAn array is said to be analogous to the secret array if all of the following conditions are true:• The length of the array is equal to the length of the secret array.• Each integer in the array lies in the interval [lowerBound, upperBound].• The difference between each pair of consecutive integers of the array must be equal to the difference between the respective pair of consecutive integers in the secret array. In other words, let the secret array be [s[0], s[1],…, s[n-1]] and let the analogous array be [a[0], a[1],…, a[n-1]], then (a[i-1] - a[i]) must be equal to (s[i-1] - s[i]) for each i from 1 to n -1. Given the value of integers lowerBound and upperBound, inclusive, and the array of differences between each pair of consecutive integers of the secret array, find the number of arrays that are analogous to the secret array. If there is no array analogous to the secret array, return 0. For example:consecutiveDifference = [-2, -1, -2, 5]lowerBound = 3upperBound = 10 Note that none of the values is out of the bound. All possible analogous arrays are:[3, 5, 6, 8, 3][4, 6, 7, 9, 4][5, 7, 8, 10, 5] Tha answer is 3. Source: https://leetcode.com/discuss/interview-question/1332322/amazon-online-assessment-july-2021-secret-array Solution123456789101112131415161718public static int countAnalogousArrays(int[] consecutiveDifference, int lowerBound, int upperBound) { // parameter validation if (consecutiveDifference == null || consecutiveDifference.length &lt; 1 || lowerBound &gt; upperBound) { return 0; } int delta = 0, maxDelta = 0, minDelta = 0; for (int i = 0; i &lt; consecutiveDifference.length; i++) { delta += consecutiveDifference[i]; maxDelta = Math.max(maxDelta, delta); minDelta = Math.min(minDelta, delta); } int maxDiff = maxDelta - minDelta, boundGap = upperBound - lowerBound; // max difference exceeds bound gap if (maxDiff &gt; boundGap) { return 0; } return boundGap - maxDiff;}","link":"/2021/12/29/OA-Count-Analogous-Arrays/"},{"title":"The C Programming Language Chapter-1","text":"Chapter-1 A Tutorial Introduction Notes of The C programming Language Integer Division of CIn C, integer division will truncate the result to zero, regardless of whether the result is positive or negative. printf Conversion Specification %fFor example, %6.4f means printf should print the value as floating point, at least 6 characters wide (it means the total width) and 4 after the decimal point. 123456789#include &lt;stdio.h&gt;int main() { float printFloatWidth1 = 1111.222; float printFloatWidth2 = 0.2; printf(&quot;printFloatWidth1: %6.4f\\n&quot;, printFloatWidth1); printf(&quot;printFloatWidth2: %6.2f\\n&quot;, printFloatWidth2); return 0;} 12printFloatWidth1: 1111.2220printFloatWidth2: 0.20 If the valid digits of the value cannot fill the least width, printf will fill it with spaces, as illustrated in printFloatWidth2. Symbolic Constants1#define PI 3.1415 Input and OutputC provides getchar() and putchar() as the user input/output interface. Comparing with InputStream and OutputStream in Java, input and output methods in C do not specify the source, destination and whether use buffer explicitly. getchar() and putchar() implicitly set console as input source and output destination, and enable buffer. It’s worth noting that \\n is not EOF. When we enter \\n in the terminal, the program will push the buffer (including \\n itself) to the while loop including getchar(). Then getchar() will read every character till the buffer is empty, and getchar() will block on it. Although the behaviors of this ‘echo’ program like it’s processing strings, it can only recognize characters one by one. A simple example 123456void copyInput() { int c; while ((c=getchar())!=EOF) { putchar(c); }} 1234567811145151451562365346236534 151 151 Declare functions in a compatible formatWe all know if you leave empty in the definition of C function argument list, it means this function need no argument. But for the compatibility with older C programs, it would be better to use void for an explicitly empty argument list. 12345678#include &lt;stdio.h&gt;int getLine(void);int copy(void);int main() { return 0;}","link":"/2021/12/10/The-C-Programming-Language-Chapter-1/"},{"title":"LeetCode 239. Sliding Window Maximum","text":"QuestionYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: 1234567891011Input: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [3,3,5,5,6,7]Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: 12Input: nums = [1], k = 1Output: [1] Constraints: 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length Source: https://leetcode.com/problems/sliding-window-maximum/ SolutionAs the window slides, we add a new element on right and discard an element on left. Because we discard elements from the window, we use a data structure to maintain all potential max values in the future (like LeetCode 155. Min Stack). Thus, we always push the new elment in to the queue when the window expands on right. If we find that the new element is greater than several previous elements, it means that the new element becomes the new “guardian”. The previous guardians that are smaller than this new guardian can be removed from the queue. Because they will be discarded eariler than the new guardian and will never become the max. In other words, elements with a larger index and a larger corresponding value have an overwhelming advantage in competing for max. The indexes in the monotonic queue are not necessarily consecutive. And this monotonic queue guarantees that these indexes are in ascending order and their corresponding elements in nums are in descending order. Because we need to repeatedly remove elements from the head and tail of the queue and append elements to the tail of the queue, we choose LinkedList as the instance class of our monotonic queue. 1234567891011121314151617181920212223242526272829303132// monotonic deque O(n)public int[] maxSlidingWindow2(int[] nums, int k) { int len = nums.length; int[] result = new int[len - k + 1]; // part indexes of elements in current window // i_{k}(max), i_{m}, i_{n}, ..., i_{right} // \\head i_{k} &lt; i_{m} &lt; i_{n} &lt; ... &lt; i_{right} \\tail // \\head nums[i_{k}] &gt;= nums[i_{m}] &gt;= nums[i_{n}] &gt;= ... &gt;= nums[i_{right}] \\tail Deque&lt;Integer&gt; monoDeque = new LinkedList&lt;&gt;(); // queue initialization with the first window for (int i = 0; i &lt; k; i++) { while (!monoDeque.isEmpty() &amp;&amp; nums[monoDeque.getLast()] &lt; nums[i]) { monoDeque.removeLast(); } monoDeque.addLast(i); } result[0] = nums[monoDeque.getFirst()]; int left = 1, right = k; for (; right &lt; len; left++, right++) { // max is to be removed if (!monoDeque.isEmpty() &amp;&amp; monoDeque.getFirst() == left - 1) { monoDeque.removeFirst(); } while (!monoDeque.isEmpty() &amp;&amp; nums[monoDeque.getLast()] &lt; nums[right]) { monoDeque.removeLast(); } monoDeque.addLast(right); result[left] = nums[monoDeque.getFirst()]; } return result;}","link":"/2022/01/09/LeetCode-239-Sliding-Window-Maximum/"},{"title":"LeetCode 862. Shortest Subarray with Sum at Least K","text":"QuestionGiven an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1. A subarray is a contiguous part of an array. Example 1: 12Input: nums = [1], k = 1Output: 1 Example 2: 12Input: nums = [1,2], k = 4Output: -1 Example 3: 12Input: nums = [2,-1,2], k = 3Output: 3 Constraints: 1 &lt;= nums.length &lt;= 105 -105 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= 109 Source: https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ SolutionWe use prefix sum to simplify the sum of subarray. The sum of any subarray can be calculated from prefix sum. This idea is similar to the usage of common prefix/suffix in LeetCode 718. Maximum Length of Repeated Subarray. We use a for loop to traverse ends of prefix sums prefixSums[y], a monotonic queue to maintain starts of prefix sums prefixSums[x]. For valid combinations of prefix sums (i.e. prefixSums[y]-prefixSums[x]&gt;=k), smaller y, larger x and larger prefixSums[x] have advantage. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 2D DP, O(n^2), Memory Limit Exceeded// still has redundant computationpublic int shortestSubarray(int[] nums, int k) { int len = nums.length; int minLen = len + 1; // dp[i][j] is the sum of subarray nums[i:j] (both ends are inclusive) int[][] dp = new int[len][len]; for (int m = 0; m &lt; len; m++) { dp[m][m] = nums[m]; if (dp[m][m] &gt;= k) { // can also return early minLen = Math.min(minLen, 1); } } for (int i = 0; i &lt; len; i++) { for (int j = i + 1; j &lt; len; j++) { dp[i][j] = dp[i][j - 1] + nums[j]; // repeat same computation if (dp[i][j] &gt;= k) { minLen = Math.min(minLen, j - i + 1); } } } return minLen == len + 1 ? -1 : minLen;}// monotonic queue, O(n)public int shortestSubarray2(int[] nums, int k) { int len = nums.length; int minLen = len + 1; // prefixSums[i] is the sum of nums[:i] (exclusive) long[] prefixSums = new long[len + 1]; // calculate prefix sum for (int i = 1; i &lt;= len; i++) { prefixSums[i] = prefixSums[i - 1] + nums[i - 1]; } // mono-dequeue, each element is the index of prefixSums, // prefixSums[i] ascending Deque&lt;Integer&gt; monoDeque = new LinkedList&lt;&gt;(); // sum of subarray nums[x:y] (x inclusive, y exclusive) = prefixSums[y] - prefixSums[x] for (int y = 0; y &lt;= len; y++) { while (!monoDeque.isEmpty() &amp;&amp; prefixSums[y] - prefixSums[monoDeque.getFirst()] &gt;= k) { int x = monoDeque.removeFirst(); minLen = Math.min(minLen, y - x); } while (!monoDeque.isEmpty() &amp;&amp; prefixSums[y] &lt;= prefixSums[monoDeque.getLast()]) { monoDeque.removeLast(); } monoDeque.addLast(y); } return minLen == len + 1 ? -1 : minLen;}","link":"/2022/01/09/LeetCode-862-Shortest-Subarray-with-Sum-at-Least-K/"},{"title":"LeetCode 76. Minimum Window Substring","text":"QuestionGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &quot;&quot;. The testcases will be generated such that the answer is unique. A substring is a contiguous sequence of characters within the string. Example 1: 123Input: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;Output: &quot;BANC&quot;Explanation: The minimum window substring &quot;BANC&quot; includes 'A', 'B', and 'C' from string t. Example 2: 123Input: s = &quot;a&quot;, t = &quot;a&quot;Output: &quot;a&quot;Explanation: The entire string s is the minimum window. Example 3: 1234Input: s = &quot;a&quot;, t = &quot;aa&quot;Output: &quot;&quot;Explanation: Both 'a's from t must be included in the window.Since the largest window of s only has one 'a', return empty string. Constraints: m == s.length n == t.length 1 &lt;= m, n &lt;= 105 s and t consist of uppercase and lowercase English letters. Source: https://leetcode.com/problems/minimum-window-substring/ SolutionWe first expand the right end of the window to find a valid window. Then we shrink the left end to find a candidate min window. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// sliding window, Time complexity O(s.length() + t.length())public String minWindow(String s, String t) { int tLen = t.length(); int sLen = s.length(); int minWindowLen = sLen + 1; // two ends of the window with min length, both inclusive int minWindowLeft = 0, minWindowRight = 0; int left = 0, right = 0; // the dictionary that describes characters to be included in desired window Map&lt;Character, Integer&gt; dict = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; wordCount = new HashMap&lt;&gt;(); for (int i = 0; i &lt; tLen; i++) { char c = t.charAt(i); dict.put(c, dict.getOrDefault(c, 0) + 1); } // number of requirements to meet int toMeet = dict.size(); while (left &lt; sLen &amp;&amp; right &lt; sLen) { char c = s.charAt(right); if (dict.containsKey(c)) { wordCount.put(c, wordCount.getOrDefault(c, 0) + 1); if (wordCount.get(c).intValue() == dict.get(c).intValue()) { toMeet--; } // valid window while (toMeet == 0) { // check and record current min window if (right - left + 1 &lt; minWindowLen) { minWindowLen = right - left + 1; minWindowLeft = left; minWindowRight = right; } // shrink window char cRemove = s.charAt(left); if (dict.containsKey(cRemove)) { wordCount.put(cRemove, wordCount.get(cRemove) - 1); if (wordCount.get(cRemove) &lt; dict.get(cRemove)) { toMeet++; } } left++; } } // invalid window, expand right end right++; } return minWindowLen == sLen + 1 ? &quot;&quot; : s.substring(minWindowLeft, minWindowRight + 1);}","link":"/2022/01/09/LeetCode-76-Minimum-Window-Substring/"},{"title":"LeetCode 1044. Longest Duplicate Substring","text":"QuestionGiven a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap. Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is &quot;&quot;. Example 1: 12Input: s = &quot;banana&quot;Output: &quot;ana&quot; Example 2: 12Input: s = &quot;abcd&quot;Output: &quot;&quot; Constraints: 2 &lt;= s.length &lt;= 3 * 104 s consists of lowercase English letters. Source: https://leetcode.com/problems/longest-duplicate-substring/ SolutionOne intuitive idea is 2D DP, which has a O(n^2) time complexity. Finding duplicate substring in one string can be regarded as a variant of the problem of finding common substrings between two strings, like LeetCode 718. Maximum Length of Repeated Subarray. How to solve this problem faster? The key point is how to determine whether two substring are identical. To prove that two substring are identical, we have to compare their characters one by one. However, we do not have to do so to be sure that two substring are not identical. Instead, if the hash values of two substrings are not the same, these two substrings must be different. Computing the hash value of each substring is still time consuming. We use rolling hash function, which treats character in a string as digits and takes the numeric value of these digits as the hash value. Thus, for a new string that only changes a few characters (in this problem, the first and the last), rolling hash function can compute the new hash value quickly. In the rolling hash function, we use a large prime number 10^9+7 to avoid overflow. A long duplicate string must contain shorter duplicate strings. Also, we only care about the longest duplicate substring. We can use binary search to find the largest length of duplicate substring. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @param L length of duplicate strings * @param base base of numeric strings * @param N length of the original string * @param nums numeric array of the original string * @return the start index of a duplicate string, if not exist, return -1 */private int searchDuplicateStrings(int L, int base, long modulus, int N, int[] nums) { long hash = 0; // hash code long highest = 1; // base^(L-1) for (int i = 0; i &lt; L; i++) { hash = (hash * base + nums[i]) % modulus; } for (int i = 1; i &lt; L; i++) { highest = (highest * base) % modulus; } // hash code -&gt; a list of start indexes Map&lt;Long, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // add the first substring map.put(hash, new ArrayList&lt;&gt;()); map.get(hash).add(0); for (int left = 1; left &lt;= N - L; left++) { // update hash value while avoiding overflow hash = (hash - nums[left - 1] * highest % modulus + modulus) % modulus; hash = (hash * base + nums[left + L - 1]) % modulus; if (map.containsKey(hash)) { List&lt;Integer&gt; starts = map.get(hash); // compare substrings with the same hash code for (int start : starts) { boolean isSame = true; for (int i = 0; i &lt; L; i++) { if (nums[i + left] != nums[i + start]) { isSame = false; break; } } if (isSame) { return left; } } starts.add(left); } else { map.put(hash, new ArrayList&lt;&gt;()); map.get(hash).add(left); } } return -1;}// average O(nlog(n))public String longestDupSubstring(String s) { int sLen = s.length(); int[] nums = new int[sLen]; // modulus for rolling hash function // a large prime number that fits into 32-bit integer final long modulus = (long) Math.pow(10, 9) + 7; // base of numeric strings final int a = 26; for (int i = 0; i &lt; sLen; i++) { nums[i] = s.charAt(i) - 'a'; } // binary search int low = 1, high = sLen; int resultLen = 0, resultIndex = -1; while (low &lt;= high) { int mid = low + (high - low) / 2; int index = searchDuplicateStrings(mid, a, modulus, sLen, nums); if (index == -1) { // no duplicate substrings with length of mid high = mid - 1; } else { // duplicate substrings with length of mid exist resultIndex = index; resultLen = mid; low = mid + 1; } } return resultLen == 0 ? &quot;&quot; : s.substring(resultIndex, resultIndex + resultLen);}","link":"/2022/01/10/LeetCode-1044-Longest-Duplicate-Substring/"},{"title":"Coding Math","text":"Modular arithmetic$a\\equiv b\\space(\\text{mod}\\space n)$ means a mod n = b mod n. The parentheses mean that $(\\text{mod}\\space n)$ applies to the entire equation, not just to the right-hand side. Reflexivity, Symmetry and Transitivity: $a\\equiv a\\space(\\text{mod}\\space n)$ $a\\equiv b\\space(\\text{mod}\\space n) \\Leftrightarrow b\\equiv a\\space(\\text{mod}\\space n)$ If $a\\equiv b\\space(\\text{mod}\\space n)$ and $b\\equiv c\\space(\\text{mod}\\space n)$, then $a\\equiv c\\space(\\text{mod}\\space n)$ If $a_1\\equiv b_1\\space(\\text{mod}\\space n)$ and $a_2\\equiv b_2\\space(\\text{mod}\\space n)$, or if $a\\equiv b\\space(\\text{mod}\\space n)$, then: $a+k\\equiv b+k\\space(\\text{mod}\\space n)$, for any integer $k$ $ka\\equiv kb\\space(\\text{mod}\\space n)$, for any integer $k$ $a_1+a_2\\equiv b_1+b_2\\space(\\text{mod}\\space n)$ $a_1-a_2\\equiv b_1-b_2\\space(\\text{mod}\\space n)$ $a_1a_2\\equiv b_1b_2\\space(\\text{mod}\\space n)$ $a^k\\equiv b^k\\space(\\text{mod}\\space n)$, for any non-negative integer $k$ $p(a)\\equiv p(b)\\space(\\text{mod}\\space n)$, for any polynomial $p(x)$ with integer coefficients Compatibility with translation, scaling, addition, subtraction, multiplication, exponentiation and polynomial evaluation.","link":"/2022/01/10/Coding-Math/"},{"title":"LeetCode 56. Merge Intervals","text":"QuestionGiven an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: 123Input: intervals = [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: intervals = [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 Source: https://leetcode.com/problems/merge-intervals/ SolutionFor interval problems, sorting the interval array by start is usually a cracking direction. For sorted interval array, if prev.end &lt; curr.start, there is no overlap between these two intervals Otherwise, they are overlapped. 12345678910111213141516171819202122public int[][] merge(int[][] intervals) { // sort by the start in ascending order Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); Deque&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); merged.add(intervals[0]); for (int[] interval : intervals) { int[] last = merged.getLast(); if (last[1] &lt; interval[0]) { merged.addLast(interval); } else { // merge last[1] = Math.max(last[1], interval[1]); } } int[][] result = new int[merged.size()][]; merged.toArray(result); return result;}","link":"/2022/01/12/LeetCode-56-Merge-Intervals/"},{"title":"LeetCode 378. Kth Smallest Element in a Sorted Matrix","text":"QuestionGiven an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n^2). Example 1: 123Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8Output: 13Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 Example 2: 12Input: matrix = [[-5]], k = 1Output: -5 Constraints: n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 300 -109 &lt;= matrix[i][j] &lt;= 109 All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order. 1 &lt;= k &lt;= n2 Source: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ SolutionGenerally, there are three ways to find the kth smallest/largest element: 1. Max Heap 2. Min Heap 3. Quick Sort. We will skip quicksort for now in this blog post. If using max heap, we should instantiate a max heap with size of k, and fill the heap with the first k elements of the matrix (it is the initilization process). Then we traverse the rest of elements in the matrix. If an element e is greater than the heap top, drop it; otherwise, pop the heap top and push element e. After this process, elements in the max heap are k-smallest elements. And the heap top is the result. However, because we need to traverse the whole matrix (can be optimized but still on the order of O(n^2)) and do not utilize the order feature of given matrix, the time complexity will be O(n^2*log(k)). In the other solution, we treat a sorted matrix as n sorted list. So it can be regarded as an extension of finding kth smallest element in two sorted list. The difference is that we do not use n variables to store indexes on list and compare them, but use a min heap to do this job. The main difference between max heap solution and min heap solution: We use the max heap to find k-smallest elements by traverse the matrix and comparing elements with the heap top. For min heap, we get k-smallest elements by other means and use min heap to find largest one of them (the kth smallest element). 1234567891011121314151617181920212223242526272829303132333435363738class element { // matrix[x][y] int val; int x; int y; public element(int _val, int _x, int _y) { this.val = _val; this.x = _x; this.y = _y; }}// min heap, Time Complexity O(k*log(k))public int kthSmallest2(int[][] matrix, int k) { int n = matrix.length; int numSortedRow = Math.min(n, k); PriorityQueue&lt;element&gt; minHeap = new PriorityQueue&lt;&gt;(numSortedRow, new Comparator&lt;element&gt;() { @Override public int compare(element o1, element o2) { return o1.val - o2.val; } }); for (int i = 0; i &lt; numSortedRow; i++) { minHeap.add(new element(matrix[i][0], i, 0)); } int result = 0; // treat a sorted matrix as n sorted lists for (int count = 0; count &lt; k; count++) { element e = minHeap.poll(); result = e.val; if (e.y &lt; n - 1) { minHeap.add(new element(matrix[e.x][e.y + 1], e.x, e.y + 1)); } } return result;}","link":"/2022/01/18/LeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/"},{"title":"LeetCode 121. Best Time to Buy and Sell Stock","text":"QuestionYou are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: 1234Input: prices = [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: 123Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 Source: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ SolutionThe best time to buy and sell can be interpreted as two forms: the lowest price we have ever seen to buy + current price to sell current price to buy + the highest price in the future to sell To solve these problems of a flexible window, one key point is to get a reliable value of one end first and traverse the other end. In the following implementation, we choose the first form so we traverse the array from the left to the right. 1234567891011121314public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int maxProfit = 0; // min price that has been seen int minPrice = Integer.MAX_VALUE; for (int price : prices) { minPrice = Math.min(minPrice, price); // the max profit if selling the stock on the ith day maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit;}","link":"/2022/01/18/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock/"},{"title":"LeetCode 123. Best Time to Buy and Sell Stock III","text":"QuestionYou are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: 1234Input: prices = [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: 1234Input: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. Constraints: 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 Source: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ SolutionleftProfits[i] means the max profit of all transactions in prices[:i] (they can sell on day i or earlier). Similar for rightProfits[i]. The overlap point of day i for leftProfits[i] and rightProfits[i] is necessary. Because the question requires a result with at most two transactions. The overlap point can help two transactions to be merged into one. We find seen min price and max price from two different ends to fill two cache arrays. 1234567891011121314151617181920212223242526public int maxProfit(int[] prices) { if (prices == null || prices.length &lt;= 1) { return 0; } int len = prices.length; // leftProfits[i] is the max profit of the first transaction in prices[:i] (inclusive) // rightProfits[i] is the max profit of the second transaction in prices[i:] (inclusive) // when two transactions overlap on i, they can be merged into one int[] leftProfits = new int[len]; int[] rightProfits = new int[len]; int leftMin = prices[0]; int rightMax = prices[len - 1]; // k is the distance to the end, to merge two loops into one for (int k = 1; k &lt; len; k++) { int l = k, r = len - 1 - k; leftMin = Math.min(leftMin, prices[l]); rightMax = Math.max(rightMax, prices[r]); leftProfits[l] = Math.max(leftProfits[l - 1], prices[l] - leftMin); rightProfits[r] = Math.max(rightProfits[r + 1], rightMax - prices[r]); } int maxProfit = 0; for (int i = 0; i &lt; len; i++) { maxProfit = Math.max(maxProfit, leftProfits[i] + rightProfits[i]); } return maxProfit;}","link":"/2022/01/18/LeetCode-123-Best-Time-to-Buy-and-Sell-Stock-III/"},{"title":"LeetCode 188. Best Time to Buy and Sell Stock IV","text":"QuestionYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: 123Input: k = 2, prices = [2,4,1]Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: 123Input: k = 2, prices = [3,2,6,5,0,3]Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints: 0 &lt;= k &lt;= 100 0 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 Source: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ SolutionTo find an efficient solution for this type of problem, we need to use DP. However, let us consider an extreme case fisrt. We are allow to make at most k transactions. If k is large enough to enable us to grab every profit, we do not have to do DP but just traverse the array once. The threshold of this k is n/2. Because a stock can rise at most n/2 times (two rises on two adjacent days can be merged into one). This is the idea of quickSolve(). For DP, the essence of DP is to solve small sub-problems first, and derive the results from these small sub-problem to larger problems. This max profit problem has two dimensions: 1. the number of days; 2. the max number of transactions allowed. So we creaste a 2D DP cache. And because deriving results from fewer days to more days is easier than changing max number of transactions, we make k+1 (more convenient than k) the first dimension and n the second dimension. Always use a variable that is easier to derive as the second dimension in 2D DP. dp[i][j] represents the max profit of prices[:j] (inclusive) with at most i transactions. Thus, there are only two options for dp[i][j]: sell the stock on jth day or not. If sell, we need to iterate all possible cases to find the max profit. If not, dp[i][j] should be equal to dp[i][j-1]. So, we can get the following formulas for these two situations: dp[i][j] = dp[i][j-1]. t is the date the last transaction was brought. dp[i][j] = for t: 0-&gt;j-1, max(dp[i-1][t-1]+prices[j]-prices[t]) . This solution still has a O((n^2)*k) time complexity. The bottleneck is the second formula. However, we can further optimize it. It is equivalent to for t: 0-&gt;j-1, max(dp[i-1][t-1]-prices[t])+prices[j]. Thus, we can find the max of the second formula while iterating 0 to j-1 once. Finally, the time complexity is optimized to O(nk). 1234567891011121314151617181920212223242526272829// return the max profit without limiting the number of transactionsprivate int quickSolve(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { // short-term trading maxProfit += Math.max(0, prices[i] - prices[i - 1]); } return maxProfit;}// Time Complexity O(nk)public int maxProfit(int k, int[] prices) { int n = prices.length; // if k allows us to get every profit if (k &gt;= n / 2) { return quickSolve(prices); } // dp[i][j] is the max profit of prices[:j] (inclusive) with at most i transactions int[][] dp = new int[k + 1][n]; for (int i = 1; i &lt;= k; i++) { // dp[i-1][t-1]-prices[t] int maxTemp = -prices[0]; for (int j = 1; j &lt; n; j++) { dp[i][j] = Math.max(dp[i][j - 1], maxTemp + prices[j]); maxTemp = Math.max(maxTemp, dp[i - 1][j - 1] - prices[j]); } } return dp[k][n - 1];}","link":"/2022/01/24/LeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV/"},{"title":"LeetCode 252. Meeting Rooms","text":"QuestionGiven an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings. Example 1: 12Input: intervals = [[0,30],[5,10],[15,20]]Output: false Example 2: 12Input: intervals = [[7,10],[2,4]]Output: true Constraints: 0 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt; endi &lt;= 106 Source: https://leetcode.com/problems/meeting-rooms/ SolutionSort intervals by start. 12345678910111213141516// sort, O(nlog(n))public boolean canAttendMeetings(int[][] intervals) { // sort intervals by the start in ascending order Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i - 1][1] &gt; intervals[i][0]) { return false; } } return true;}","link":"/2022/01/24/LeetCode-252-Meeting-Rooms/"},{"title":"LeetCode 253. Meeting Rooms II","text":"QuestionGiven an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required. Example 1: 12Input: intervals = [[0,30],[5,10],[15,20]]Output: 2 Example 2: 12Input: intervals = [[7,10],[2,4]]Output: 1 Constraints: 1 &lt;= intervals.length &lt;= 104 0 &lt;= starti &lt; endi &lt;= 106 Source: https://leetcode.com/problems/meeting-rooms-ii/ SolutionWe can simulate the schedule of meeting rooms by a min heap of ends of intervals. Because when a new meeting comes in, we only need to compare its start time with the end time of the earliest ending meeting, and decide whether we should add one more room. Note that in the following implementation, we poll at most one element from the heap per loop, rather than polling all terminated meetings, because we choose return the size of the heap as the result. Logically chronological ordering solution is further optimized, though its time complexity is the same heap-based solution, O(nlog(n)). The idea is break the relationship between start and end. We sort starts and ends separately, and use two pointers to traverse them. We can still get the correct result because we do not care about which meeting ends and makes a room spare, but the timepoint of the end. One evidence is that in the heap-based solution, we only stores ends of intervals in the heap. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// heap, O(nlog(n))public int minMeetingRooms(int[][] intervals) { if (intervals.length == 0) { return 0; } // sort intervals by the start in ascending order Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); // min heap of end of interval PriorityQueue&lt;Integer&gt; endMinHeap = new PriorityQueue&lt;&gt;(intervals.length, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); endMinHeap.add(intervals[0][1]); for (int i = 1; i &lt; intervals.length; i++) { int[] curr = intervals[i]; // try to find a free room if (curr[0] &gt;= endMinHeap.peek()) { endMinHeap.poll(); } endMinHeap.add(curr[1]); } return endMinHeap.size();}// Chronological Ordering, O(nlog(n))public int minMeetingRooms2(int[][] intervals) { int len = intervals.length; if (len == 0) { return 0; } int[] starts = new int[len]; int[] ends = new int[len]; for (int i = 0; i &lt; len; i++) { starts[i] = intervals[i][0]; ends[i] = intervals[i][1]; } // sort respectively by ascending order // we want to know if there is an empty room at a certain point in time, // but don't care which meeting room it is Arrays.sort(starts); Arrays.sort(ends); int startIndex = 0, endIndex = 0; int numRoom = 0; while (startIndex &lt; len &amp;&amp; endIndex &lt; len) { if (starts[startIndex] &gt;= ends[endIndex]) { startIndex++; endIndex++; } else { startIndex++; numRoom++; } } return numRoom;}","link":"/2022/01/24/LeetCode-253-Meeting-Rooms-II/"},{"title":"LeetCode 452. Minimum Number of Arrows to Burst Balloons","text":"QuestionThere are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons. Example 1: 12345Input: points = [[10,16],[2,8],[1,6],[7,12]]Output: 2Explanation: The balloons can be burst by 2 arrows:- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. Example 2: 123Input: points = [[1,2],[3,4],[5,6],[7,8]]Output: 4Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. Example 3: 12345Input: points = [[1,2],[2,3],[3,4],[4,5]]Output: 2Explanation: The balloons can be burst by 2 arrows:- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. Constraints: 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 Source: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// sort by end, greedy, Time Complexity O(nlog(n))public int findMinArrowShots(int[][] points) { if (points == null || points.length == 0) { return 0; } // sort by end in ascending order Arrays.sort(points, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // in case of overflow if (o1[1] == o2[1]) { return 0; } else if (o1[1] &gt; o2[1]) { return 1; } else { return -1; } } }); int prevEnd = points[0][1]; int numArrow = 1; for (int[] point : points) { if (point[0] &gt; prevEnd) { // no overlap numArrow++; prevEnd = point[1]; } } return numArrow;}// sort by start, greedy, Time Complexity O(nlog(n))public int findMinArrowShots2(int[][] points) { if (points == null || points.length == 0) { return 0; } // sort by start in ascending order Arrays.sort(points, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // in case of overflow if (o1[0] == o2[0]) { return 0; } else if (o1[0] &gt; o2[0]) { return 1; } else { return -1; } } }); int minEnd = points[0][1]; int numArrow = 1; for (int[] point : points) { if (point[0] &gt; minEnd) { // no overlap numArrow++; minEnd = point[1]; } else { minEnd = Math.min(minEnd, point[1]); } } return numArrow;}","link":"/2022/01/25/LeetCode-452-Minimum-Number-of-Arrows-to-Burst-Balloons/"},{"title":"LeetCode 435. Non-overlapping Intervals","text":"QuestionGiven an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Example 1: 123Input: intervals = [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping. Example 2: 123Input: intervals = [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping. Example 3: 123Input: intervals = [[1,2],[2,3]]Output: 0Explanation: You don't need to remove any of the intervals since they're already non-overlapping. Constraints: 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 Source: https://leetcode.com/problems/non-overlapping-intervals/ Solution1234567891011121314151617181920212223242526272829// sort by start, greedy, Time Complexity O(nlog(n))public int eraseOverlapIntervals(int[][] intervals) { if (intervals == null || intervals.length == 0) { return 0; } Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); int numRemove = 0; int prevEnd = intervals[0][1]; for (int i = 1; i &lt; intervals.length; i++) { int[] curr = intervals[i]; if (curr[0] &gt;= prevEnd) { // no overlap prevEnd = curr[1]; } else if (prevEnd &lt; curr[1]) { // intersection overlap // remove current interval // do not change prevEnd numRemove++; } else { // included overlap // remove previous interval numRemove++; prevEnd = curr[1]; } } return numRemove;}","link":"/2022/01/25/LeetCode-435-Non-overlapping-Intervals/"}],"tags":[{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Monotonic","slug":"Monotonic","link":"/tags/Monotonic/"},{"name":"Delta","slug":"Delta","link":"/tags/Delta/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Substring","slug":"Substring","link":"/tags/Substring/"},{"name":"Common Substring","slug":"Common-Substring","link":"/tags/Common-Substring/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Prefix Sum","slug":"Prefix-Sum","link":"/tags/Prefix-Sum/"},{"name":"Rolling Hash","slug":"Rolling-Hash","link":"/tags/Rolling-Hash/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Interval","slug":"Interval","link":"/tags/Interval/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Programming Tips","slug":"Programming-Tips","link":"/categories/Programming-Tips/"},{"name":"Algorithm Template","slug":"Algorithm-Template","link":"/categories/Algorithm-Template/"},{"name":"C - K&amp;R","slug":"C-K-R","link":"/categories/C-K-R/"},{"name":"Math","slug":"Math","link":"/categories/Math/"}]}