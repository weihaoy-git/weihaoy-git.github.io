{"pages":[],"posts":[{"title":"A Brief Introduction to Dynamic Programming","text":"Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. example 123456789101112131415161718192021// recursionpublic int fib(int n) { if(n&lt;=1) return n; return fib(n-1)+fib(n-2);}// dynamic programmingpublic int fibDP(int n) { if (n&gt;1) { int fib=0, p1=1,p2=0; for (int i=2;i&lt;=n;i++) { fib = p1+p2; p2 = p1; p1 = fib; } return fib; } else if (n==1) { return 1; } else { return 0; }} Two pattern of solving DP problem: Tabulation: bottom up Memoization: top down","link":"/2021/12/22/A-Brief-Introduction-to-Dynamic-Programming/"},{"title":"Java Programming Tips","text":"Convert char to int12char c = '9';int i = Character.getNumericValue(c); 12char c = '9';int i = c - '0'; Add zeros at the beginning of a number12int i = 640;System.out.printf(&quot;%05d\\n&quot;, i); 100640 Fill an arrayUse Arrays.fill(array, val) to assign values to an array. 123int[] a = new int[10];Arrays.fill(a, 7);System.out.println(Arrays.toString(a)); 1[7, 7, 7, 7, 7, 7, 7, 7, 7, 7] Convert between string and char array123char[] arr = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};String s = new String(arr);char[] arr2 = s.toCharArray(); Convert integer to string123String s1 = String.valueOf(i);String s2 = Integer.toString(i, 10); // radix = 10String s3 = String.format(&quot;%d&quot;, i); Default initialization of an array in JavaEverything in a Java program not explicitly set to something by the programmer, is initialized to a zero value. For references (anything that holds an object) that is null. For int/short/byte/long that is a 0. For float/double that is a 0.0 For booleans that is a false. For char that is the null character '\\u0000' (whose decimal equivalent is 0). Reverse a List1Collections.reverse(list); Create a List from an arrayTake the return of Array.asList() as the parameter of ArrayList constructor. 12int[] array = new int[10];ArrayList&lt;Integer&gt; arraylIST = new ArrayList&lt;&gt;(Arrays.asList(array)); Sort Primitive array: Arrays.sort(arr) Object array: Arrays.sort(integerArr, comparator) List: Collections.sort(list, comparator) 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Traverse a mapUse Map.Entry or HashMap.Entry. 1234HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();for (HashMap.Entry&lt;Integer, Integer&gt; e:hashMap.entrySet()) { // do something} isLetter() and isAlphabetic()isLetter() and isAlphabetic() are two methods of Character. The difference between them is: isAlphabetic() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER &amp;&amp; LETTER_NUMBER. isLetter() checks UPPERCASE_LETTER &amp;&amp; LOWERCASE_LETTER &amp;&amp; TITLECASE_LETTER &amp;&amp; MODIFIER_LETTER &amp;&amp; OTHER_LETTER. The point is that isLetter() will return false given a letter number. For example, roman numeral five (the letter looks like “V”). Certainly, for the English language, the distinction makes no difference. Use Deque over Stack for LIFO stacksWe should use Deque rather than Stack for LIFO stacks. 12Deque&lt;Integer&gt; dstack = new ArrayDeque&lt;&gt;();Stack&lt;Integer&gt; sstack = new Stack&lt;&gt;(); // not recommended There are many reasons to prefer Deque: Deque is an interface but Stack is a class. So using Deque brings us more flexibility for future extension. Stack is synchronized but Deque is not thread-safe. In the case of no need to ensure thread safety, Deque is more efficient. Deque iterates elements from top to bottom. Stack iterates elements from bottom to top. Most important: with Stack, we can access/insert/remove arbitrary elements in the LIFO stack by indexes, stack.get(index); stack.add(index, e); stack.remove(index), which breaks the LIFO rule. Although Deque does not absolutely obey the LIFO rule, it can only access/insert/remove the first/last element in the LIFO stack. Print multi-dimensional arrays12System.out.println(Arrays.toString(arr)); // print a 1D arraySystem.out.println(Arrays.deepToString(marr)); // print a multi-dimensional array Get ceiling/floor value of a number12double ceilingValue = Math.ceil(3.1); // 4.0double floorValue = Math.floor(3.1); // 3.0 Note that these twoMath functions return double. Or if we need to get the ceiling value of a fraction X/Y, we can also do as the following: 1int res = (X + Y - 1) / Y; Sort an array/list Primitive array int[]: Arrays.sort Objective array Integer[]: Arrays.sort and optional comparator Objective list List&lt;Integer&gt;: Collections.sort and optional comparator 12345678910111213141516int[] arr = new int[]{4, 1, 5, 4, 4, 0, 6, 1, 9};Integer[] integerArr = new Integer[]{4, 1, 5, 4, 4, 0, 6, 1, 9};List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(integerArr));Arrays.sort(arr);Arrays.sort(integerArr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }});Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); }}); Common time complexity calculation$$\\sum_{1}^{n}{k^2}=\\frac{1}{n}{n(n+1)(2n+1)}=O(n^3)\\\\sum_{1}^{n}{k^3}=(\\frac{1}{2}{n(n+1)})^2=O(n^4)$$ String manipulation1234StringBuilder builder1 = new StringBuilder(&quot;abcdefg&quot;);// if we want to delete c and add it backbuilder1.deleteCharAt(2); // &quot;abdefg&quot;builder1.insert(2, 'c'); // &quot;abcdefg&quot; toCharArray() and getBytes()toCharArray() is better if we are not dealing with characters outside of the Unicode BMP, which are encoded as two surrogate characters. getBytes() needs to specify encoding, which is prone to mistakes. Also, toCharArray() is faster because for Java 7 and newer, a String object contains a char array internally. toCharArray() just need to complete a copy operation. Integer object comparisonFor two Integer objects, == compares their references while &lt; and &gt; compare their values. To examinate whether they have the same value, we should use equals() or unbox them by intValue(). And, it is safe to use comparison operators (==, &lt;, &gt;) for comparing values between an int and an Integer object. 1234567Integer i1 = new Integer(15640);Integer i2 = new Integer(15640);Integer i3 = new Integer(15440);System.out.printf(&quot;i1 == i2 : %b\\n&quot; + &quot;i1.value == i2.value : %b\\n&quot; + &quot;i1.equals(i2) : %b\\n&quot; + &quot;i2 &gt; i3 : %b\\n&quot;, i1 == i2, i1.intValue() == i2.intValue(), i1.equals(i2), i2 &gt; i3); 1234i1 == i2 : falsei1.value == i2.value : truei1.equals(i2) : truei2 &gt; i3 : true substring()substring(beginIndex, endIndex) returns the substring in [beginIndex, endIndex). And it is safe for beginIndex == endIndex == 0 or length. 123String s = &quot;hello&quot;;System.out.println(s.substring(0, 0)); // return &quot;&quot;System.out.println(s.substring(s.length(), s.length())); // return &quot;&quot; indexOf()s.indexOf(pattern, fromIndex) returns the first index of given pattern from fromIndex (inclusive). If such pattern does not exist, it returns -1.","link":"/2021/12/22/Java-Programming-Tips/"},{"title":"Common Algorithm Implementation Templates","text":"Traverse an array by groups123456for (int i = 0; i &lt; arr.length; i += interval) { for (int j = i; j &lt; i + interval &amp;&amp; j &lt; arr.length; j++) { // do something } // do something}","link":"/2022/01/05/Common-Algorithm-Implementation-Templates/"},{"title":"LeetCode 1048. Longest String Chain","text":"QuestionYou are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;, while &quot;cba&quot; is not a predecessor of &quot;bcad&quot;. A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1. Return the length of the longest possible word chain with words chosen from the given list of words. Example 1: 123Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]Output: 4Explanation: One of the longest word chains is [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]. Example 2: 123Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]Output: 5Explanation: All the words can be put in a word chain [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;]. Example 3: 1234Input: words = [&quot;abcd&quot;,&quot;dbqca&quot;]Output: 1Explanation: The trivial word chain [&quot;abcd&quot;] is one of the longest word chains.[&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed. Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 16 words[i] only consists of lowercase English letters. Source: https://leetcode.com/problems/longest-string-chain/ SolutionBottom-Up DP For words, the length of longest string chain that ends with word equals $max(pre_0(word),pre_1(word),…,pre_{l-1}(word))+1$ 1234567891011121314151617181920212223242526272829303132public int longestStrChain(String[] words) { // parameter validation if (words == null || words.length &lt; 1) { return 0; } // s -&gt; max length of string chain ending with s Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); // sort words by length of each word Arrays.sort(words, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }); int len = words.length; int maxLen = 0; for (int i = 0; i &lt; len; i++) { int currLen = 1; StringBuilder temp = new StringBuilder(words[i]); for (int k = 0; k &lt; words[i].length(); k++) { char c = temp.charAt(k); temp.deleteCharAt(k); String predecessor = temp.toString(); int prevLen = cache.getOrDefault(predecessor, 0); currLen = Math.max(currLen, prevLen + 1); temp.insert(k, c); // restore the change } cache.put(words[i], currLen); maxLen = Math.max(maxLen, currLen); } return maxLen;}","link":"/2021/12/30/LeetCode-1048-Longest-String-Chain/"},{"title":"Go Programming Tips","text":"Add 0x prefix when printing hex numbersUse %#x placeholder. 12345func TestPrintHex() { var i int = 0x123456 fmt.Printf(&quot;%x\\n&quot;, i) fmt.Printf(&quot;%#x\\n&quot;, i)} 121234560x123456 Print the type of a variable123fmt.Printf(&quot;%T\\n&quot;, i)fmt.Println(reflect.Typeof(i))fmt.Prinft(&quot;%s\\n&quot;, reflect.Typeof(i).String()) Get random numbersIntn() returns the next integer in the current random sequence. UnixNano() returns the number of nanoseconds elapsed since January 1, 1970 UTC. And the result of UnixNano() does not depend on the location associated with t. We only have to set the seed once. But before we set the seed, rand will use the default seed. For example, the first call of Intn(100) always returns 81 without setting the seed. 12rand.Seed(time.Now().UnixNano())fmt.Println(rand.Intn(100)) Temporary variables in if-else blockIn Go, we can define variables in if-else condition statement. The scope of these temporary variables is limited within if-else block. 12345if v, p := math.Sqrt(float64(sum)), math.Sin(float64(sum)); v &lt; 10 &amp;&amp; p &lt; 0.5 { fmt.Println(&quot;True&quot;)} else { fmt.Println(v, p)} switchIn Go, the execution does not fall through the switch structure. Switch cases evaluate cases from top to bottom, stopping when a case succeeds. Also, if we want to take the same action on multiple cases, we can write case content1, content2:. In the following example, although without any break, the control flow jumps out of the switch block after executing the first case. 123456789var i int = 15640switch {case i &gt; 1: fmt.Println(i)case i &gt; 2: fmt.Println(i)case i &gt; 99999: fmt.Println(&quot;false&quot;)} 115640 SliceSlices share the same underlying memory with the original array. The type of slice is []T. len() returns the number of elements a slice contains. cap() returns the number of elements in the underlying array, counting from the first element in the slice. append(slice, e1, e2, ...) overwrites the elements in the underlying array if slice has enough capacity to contain these elements. Otherwise, it returns a new allocated slice and keeps the underlying array intact. 123456789101112131415161718192021222324func TestSlice() { var arr [5]int = [5]int{0, 1, 2, 3, 4} slice1 := arr[0:4] slice2 := arr[1:4] fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(arr).String(), len(arr), cap(arr)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice1).String(), len(slice1), cap(slice1)) fmt.Printf(&quot;type: %s, len: %d, cap: %d\\n&quot;, reflect.TypeOf(slice2).String(), len(slice2), cap(slice2)) slice1[0] = 9 fmt.Println(arr) fmt.Println(slice1) fmt.Println(slice2, &quot;\\n&quot;) // Test slice append slice3 := append(slice2, 8) // change the underlying array slice4 := append(slice2, 7, 6) // return a new allocated slice fmt.Println(arr, &amp;arr[0], cap(arr)) fmt.Println(slice1, &amp;slice1[0], cap(slice1)) fmt.Println(slice2, &amp;slice2[0], cap(slice2)) fmt.Println(slice3, &amp;slice3[0], cap(slice3)) fmt.Println(slice4, &amp;slice4[0], cap(slice4))} 123456789101112131415[0 1 2 3 4][0 1 2 3][1 2 3]type: [5]int, len: 5, cap: 5type: []int, len: 4, cap: 5type: []int, len: 3, cap: 4[9 1 2 3 4][9 1 2 3][1 2 3] [9 1 2 3 8] 0xc000018270 5[9 1 2 3] 0xc000018270 5[1 2 3] 0xc000018278 4[1 2 3 8] 0xc000018278 4[1 2 3 7 6] 0xc00001e080 8 Variable Length ArrayGo only allows constants to be used as array size. To create an array whose size is defined by a variabl, we can use make([]T, length). It creates an underlying array with size of length and returns a slice of it. 12345678910111213const conLen = 8func TestVLA(length int) { var l int = 5 // illegal //var arr0 [len]int //var arr1 [l]int var arr2 = make([]int, l) var arr3 = make([]int, length) var arr4 [conLen]int // do something} String comparisonIn Go, we can compare strings by using comparison operators (==, &lt;, &gt;, etc) or by strings.Compare(s1, s2). File naming conventionsnake_case is the convention across the most of the standard library and most third party libraries for Go. deferdefer FunctionCall() defers the execution of FunctionCall() until the surrounding function (the parent function call of FunctionCall()) returns. Multiple deferred calls are stacked, so that they will be callled in a LIFO order. 123456func TestDefer() { for i:= 0; i &lt; 5; i++ { defer fmt.Println(&quot;deferred call&quot;, i) } fmt.Println(&quot;ready to return&quot;)} 123456ready to returndeferred call 4deferred call 3deferred call 2deferred call 1deferred call 0 HashmapIn Go, we can declaring a hashmap by using key word map. map declares a non-thread-safe hashmap. Create a hash map: hashmap := make(map[string]int), string is key type and int is value type. Insert a key-value pair: hashmap[key] = value. Delete a key-value pair: delete(hashmap, key). Check whether a key exists: v, ok := hashmap[key]. If the key exists, ok == true. Otherwise, v equals to the zero value of the value type, ok == false. Traverse the hashmap: for k, v := range hashmap {// do someting} Difference between make and new make returns a value of T; new returns a value of *T. make returns an initialized value; new returns a zeroed value. make can only create and initialize slices, maps and channels; new can allocate zeroed memory for any types. Take hashmap as an example. Since we need to initialize structure of hashmap itself before using it (it means that we cannot just zero the hashmap memory), we have to create a hashmap by hashmap := make(map[string]int) or hashmap := map[string]int{}. Format go files recursively1go fmt path/... MethodIn Go, methods take either a value or a pointer as the receiver when they are called. Go interprets s.Print() as (&amp;s).Print(), ps.SwapPrint() as (*ps).SwapPrint(). But this is just syntactic sugar. Also, we cannot define new methods for existing types in another package (including built-in types, such as int, map). But it is fine to define a normal function that takes a non-local-package type argument. Or we can define our own alias for that type in current package type Alias ExistingTypeName, or define a wrapper structure containing that type type NewStruct struct {n ExistingTypeName} 1234567891011121314151617181920212223type MyStruct struct { x int y int}func (ps *MyStruct) Print() { fmt.Printf(&quot;(%d, %d)\\n&quot;, ps.x, ps.y)}func (s MyStruct) SwapPrint() { fmt.Printf(&quot;(%d, %d)\\n&quot;, s.y, s.x)}func TestMethod() { ps := new(MyStruct) ps.x = 12 ps.y = 24 s := MyStruct{12, 24} ps.Print() ps.SwapPrint() s.Print() s.SwapPrint()} InterfaceAny concrete types that implement all methods of a interface type satisfy implicitly that interface type. In other words, a interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface. Note that T and *T are different when it comes to the relationship between interfaces and concrete types. And we cannot define methods for types under another package. 12345678910111213141516171819202122232425type IntTask inttype FloatTask float64type Runner interface { Run()}func (pit *IntTask) Run() { fmt.Printf(&quot;running task id = %d\\n&quot;, int(*pit))}func TestInterface() { var task Runner var pit *IntTask = new(IntTask) *pit = 1 var it IntTask = 2 fmt.Println(int(*pit)) fmt.Println(int(it)) task = pit // illegal //task = id task.Run()} Since only *ID implements Run() method, *ID satisfies interface Runnable but ID does not. 12312running task id = 1 Empty interfaceinterface{} is empty interface. Because it has no methods, all types satisfy the empty interface. Interface PitfallAn interface value with a nil dynamic value is NOT the same as a nil interface for any non-empty interfaces. If we assign nil to an empty interface variable, that variable is still equal to nil. If you want to keep the interface value consistent with its concrete value, please do not define a concrete value first then assign it to the interface value, but define the interface value directly (allocate a concrete value by new). 1234567891011func TestPitfall() { var pit *IntTask // zeroed as nil var run1 Runner = pit // warning: run1 is not nil var run2 Runner // zeroed as nil var run3 Runner = new(IntTask) var emptyInterface interface{} = nil fmt.Printf(&quot;run1 == nil ? %t\\n&quot;, run1 == nil) fmt.Printf(&quot;run2 == nil ? %t\\n&quot;, run2 == nil) fmt.Printf(&quot;run3 == nil ? %t\\n&quot;, run3 == nil) fmt.Printf(&quot;emptyInterface == nil ? %t\\n&quot;, emptyInterface == nil)} 1234run1 == nil ? falserun2 == nil ? truerun3 == nil ? falseemptyInterface == nil ? true Sortsort.Ints() and sort.Strings() only accept slice as argument. sort.Sort() provide a customizable method that requires the data type to be sorted should implement Len(), Swap() and Less(). 12var arr = [10]int{2, 3, 4, 6, 7, 9, 2, 3, 4, 5}sort.Ints(arr[:]) Type AssertionThe general form of type assertion is x.(T), while x is an interface to be tested (asserted), T can be a concrete type or another interface type. There are two usages of type assertion. T is a concrete type. The type assertion checks whether the concrete type of x is identical to T. T is an interface type. The type assertion checks whether the concrete type of x satisfies interface T. A successful type assertion returns the dynamic value in type T, and an optional assertion flag. A failed type assertion returns nil and flag false, if the statement only accepts one return value, it will cause a panic. 123456789101112131415161718192021func TestTypeAssert() { var itRunner Runner = new(IntTask) var ftRunner Runner = new(FloatTask) itRunner.Run() ftRunner.Run() // if without ok flag, such as pit2 := ftRunner.(*IntTask) // false assertions will cause panic pit, okInt := itRunner.(*IntTask) pit2, okInt2 := ftRunner.(*IntTask) pft, okFloat := ftRunner.(*FloatTask) pft2, okFloat2 := itRunner.(*FloatTask) fmt.Printf(&quot;assert itRunner to *IntTask: %t %T %p\\n&quot;, okInt, pit, pit) fmt.Printf(&quot;assert ftRunner to *IntTask: %t %T %p\\n&quot;, okInt2, pit2, pit2) fmt.Printf(&quot;assert ftRunner to *FloatTask: %t %T %p\\n&quot;, okFloat, pft, pft) fmt.Printf(&quot;assert itRunner to *FloatTask: %t %T %p\\n&quot;, okFloat2, pft2, pft2) *pit = 15640 *pft = 15.64 itRunner.Run() ftRunner.Run()} Type SwitchWe can use a type switch statement to replace an if-else chain of type assertions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func TestTypeSwitch() { var i int = 15640 var j float64 = 15.64 var k string = &quot;DS&quot; TypeSwitch1(i) TypeSwitch1(j) TypeSwitch1(k) fmt.Println(&quot;&quot;) TypeSwitch2(i) TypeSwitch2(j) TypeSwitch2(k) fmt.Println(&quot;&quot;) TypeSwitch3(i) TypeSwitch3(j) TypeSwitch3(k) fmt.Println(&quot;&quot;)}func TypeSwitch1(x interface{}) { switch x := x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch2(x interface{}) { switch x.(type) { case int: fmt.Printf(&quot;case int: value = %d, type = %T\\n&quot;, x, x) case float64: fmt.Printf(&quot;case float64: value = %f, type = %T\\n&quot;, x, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }}func TypeSwitch3(x interface{}) { switch x := x.(type) { case int, float64: fmt.Printf(&quot;Valid Type: %T\\n&quot;, x) default: fmt.Printf(&quot;Unexpected Type\\n&quot;) }} 1234567891011case int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected Typecase int: value = 15640, type = intcase float64: value = 15.640000, type = float64Unexpected TypeValid Type: intValid Type: float64Unexpected Type map, channel and reference in GoFirst of all, there is NO strict reference (alias) in Go, which means two variables refer (not point) to the same memeory location. In Go, everything is passed by value. But we can see that in Go map and channel can be passed by reference in function. This is because map and channel are pointers naturally, while do not look like pointers. For example, a map variable is actually a pointer to a runtime.hmap structure. By the way, channels act as FIFO queues. Closed and drained channelRead requests (not matter how many times) to a closed and drained channel always immediately returns a zero value. But we can examine receives on a closed and drained channel by using optional flag. 1234567891011func TestChannel() { channel := make(chan int, 10) close(channel) for { x, ok := &lt;- channel if !ok { break } fmt.Println(x) }} Or we can read elements from a channel by range, which will terminate the loop after reading the last element in a closed channel. 12345678910func TestChannel() { channel := make(chan int, 10) channel &lt;- 1 channel &lt;- 2 channel &lt;- 3 close(channel) for x := range channel { fmt.Println(x) }} Unidirectional channel typeschan&lt;- T: send-only channel; &lt;-chan T: receive-only channel. They can be used in function arguments to restrict the opertions to channels. Conversions from bidirectional channel to unidirectional channel types are permitted in any assignment. But there is no going back. nil channelSend and receive operations on a nil channel block forever. selectIn select, each case specifies a communication (a send or receive operation on some channel) and an associated block of statements. If there is only one runnable case, execute that case. If there is multiple runnable cases, randomly execute one of them. If there is no runnable cases, block. The default case in a select is run if no other case is ready. We can use select and a closed channel to terminate goroutines politely. Terminate a goroutineFirst, there is no way for one goroutine to terminate another directly. If we want to terminate a goroutine, we should send a “signal” to that goroutine and let it handles the signal by executing return. This signal can be implemented by a closed and drained channel. Because each receive operations to a closed and drained channel always immediately returns a zero value. It sounds great, right? But the problem is that if a goroutine is blocked, it cannot notice the signal at the same time. Thus, we need to ensure two things: If this routine may be blocked by other methods (listener.Accept(), etc), unblock these methods in Close(), for example, by listener.Close(). If this routine may be blocked by channel operations, always wrap every channel operation with a select-done structure. In other words, every channel operation should have a done case in parallel. 1234567891011121314151617181920212223242526272829var done = make(chan bool) // always emptyvar workChan = make(chan int, 10) // a buffered channel storing datafunc Close() { // broadcast termination signal close(done)}func sampleRoutine() { // ... select { case workChan &lt;- data: // do some non-blocking tasks case &lt;-done: return } // ...}func sampleRoutine2() { // ... select { default: // do some non-blocking tasks case &lt;-done: return } // ...} If we use for range to receive data from a channel in a goroutine function, which makes it hard to receive the termination signal, it can be rewritten by for{} and select. 123456789101112131415161718192021func sampleForRange() { // terminate loop automatically when workChan is closed and drained // cannot receive for res := range workChan { // ... }}func sampleForSelect() { for { select { case res, ok := &lt;-workChan: if !ok { // workChan is closed and drained return } // ... case &lt;-done: return } }} An ingenious example of decoupling on channel operation12345678910111213141516171819202122// work routine pulls integers from input channel// squares them and pushes results to output channelfunc (sq *SquarerImpl) work() { var toPush int dummy := make(chan int) pushOn := dummy pullOn := sq.input for { select { case unsquared := &lt;-pullOn: toPush = unsquared * unsquared pushOn = sq.output pullOn = nil case pushOn &lt;- toPush: pushOn = dummy pullOn = sq.input case &lt;-sq.close: sq.closed &lt;- true return } }} The constant generator iotaIn a const declaration, the value of iota begins at zero and increments by one for each item in the sequence. 1234567891011121314151617181920const ( zero = iota // 0 one // 1 two // 2 three // 3 four // 4)const ( first = 1 + iota // 1 second // 2 third // 3)const ( _ = 1 &lt;&lt; (10 * iota) KB // 1024 MB // 1024 * 1024 GB // 1024 * 1024 * 1024) Asynchronous Request Implementation12345type Request struct { reqType ReqType retChan chan interface{} reqBody []interface{}} Remove the first element of a sliceIt also applies on slices with length of 1. 1slice = slice[1:] json.Marshaljson.Marshal(v) takes a memory object (argument type interface{}) and return its json encoding. In network programming, it can conveniently convert a user-defined object into json payload of the packet. Flexible array members in a structureGo allows us to define flexible array members (slices) in structures. Different from C, we can define any number of slices at any places in a structure. 123456789101112131415type Struct1 struct { i int body []interface{}}type Struct2 struct { body []interface{}}type Struct3 struct { i int body1 []interface{} body2 []interface{} j int} Pop from a slices = s[1:]. It removes the first element of s. Note that when using this syntax, the length of s can be 1 or greater but cannot be 0. 12345678func TestSlicePop() { s := make([]int, 1) s[0] = 16540 s = s[1:] // remove the first element fmt.Println(len(s)) // print 0 s1 := make([]int, 0) s1 = s1[1:] // ERROR!} Delete from a mapDeleting a non-existing key from a map through delete() makes no effect. 12345678func TestMapDelete() { hashmap := make(map[int]int) hashmap[1] = 1 delete(hashmap, 0) for k, v := range hashmap { fmt.Printf(&quot;[%d, %d]\\n&quot;, k, v) }} 1[1, 1] Constants in GoGo does NOT support constant members in structures or constant structures. Implement timing events by tickerWe can create a ticker through time.NewTicker(interval), which generates ticks in its channel ticker.C at specified time intervals (obviously, the size of channel C is one. We do not want ticks to be accumulated). We can place the handling functions of timing events and other events in a for-select block, so that timing events will not affect the execution of normal events. Note that Stop() will stop sending ticks to the channel C but will not close it, to prevent a closed drained channel issue. 123456789101112func TestTicker() { ticker := time.NewTicker(10 * time.Second) //ticker.Stop() for { select { case t := &lt;-ticker.C: // timing event fmt.Println(t) // case e := &lt;-normalEventChan: } }} Implicit type conversions and implicit numeric conversionsGo does not allow implicit type conversions, and does not allow implicit numeric conversions except numeric conversions across constants. 12345678910111213141516171819202122232425262728func TestType() { var i int = 10 var j int64 = 10 var k int = 10 // 1/10 == 0 =&gt; 0.0 var p float64 = 1 / 10 // 1.0/10 =&gt; 1.0/10.0 =&gt; 0.1 var q float64 = 1.0 / 10 // illegal // var m float64 = 1.0 / i _ = j // to keep compiler happy // mismatched types // j = i // mismatched types /* if i == j { fmt.Println(&quot;i == j&quot;) } */ if i == k { fmt.Println(&quot;i == k&quot;) } fmt.Println(p) fmt.Println(q) // Go does not support implicit numeric conversion // p = i / k} 123i == k00.1","link":"/2021/12/22/Go-Programming-Tips/"},{"title":"LeetCode 1335. Minimum Difficulty of a Job Schedule","text":"QuestionYou want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 &lt;= j &lt; i). You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day. You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i]. Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1. Example 1: 12345Input: jobDifficulty = [6,5,4,3,2,1], d = 2Output: 7Explanation: First day you can finish the first 5 jobs, total difficulty = 6.Second day you can finish the last job, total difficulty = 1.The difficulty of the schedule = 6 + 1 = 7 Example 2: 123Input: jobDifficulty = [9,9,9], d = 4Output: -1Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs. Example 3: 123Input: jobDifficulty = [1,1,1], d = 3Output: 3Explanation: The schedule is one job per day. total difficulty will be 3. Constraints: 1 &lt;= jobDifficulty.length &lt;= 300 0 &lt;= jobDifficulty[i] &lt;= 1000 1 &lt;= d &lt;= 10 Source: https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/ SolutionIn this problem, jobs are dependent so we can only complete jobs sequentially. For a day, we only need to consider the start job index m and the end job index n, which means on that day we complete all jobs between job m and job n (inclusive). cache[i][j] represents the minimum sum of difficulties when completing the first j+1 jobs in i+1 days. In the following code block, we traverse the start job index from high to low. It gets the max difficulty of jobs on that day more efficiently. 1234for (int k = j; k &gt;= i; k--) { dayMax = Math.max(dayMax, jobDifficulty[k]); cache[i][j] = Math.min(cache[i][j], cache[i - 1][k - 1] + dayMax);} 12345678910111213141516171819202122232425262728// bottom-up 2D DP, time complexity O(nnd), space complexity O(nd)public int minDifficulty(int[] jobDifficulty, int d) { // parameter validation if (d &lt; 1 || jobDifficulty == null || jobDifficulty.length &lt; 1 || jobDifficulty.length &lt; d) { return -1; } int n = jobDifficulty.length; // number of jobs // cache for DP // cache[i][j] represents the min sum of difficulties when completing jobs up to j job on i day int[][] cache = new int[d][n]; cache[0][0] = jobDifficulty[0]; for (int j = 1; j &lt; n; j++) { cache[0][j] = Math.max(cache[0][j - 1], jobDifficulty[j]); } for (int i = 1; i &lt; d; i++) { // only use a half of the cache because we must complete at least one job per day for (int j = i; j &lt; n; j++) { cache[i][j] = Integer.MAX_VALUE; int dayMax = Integer.MIN_VALUE; // k is the index of start job on i day for (int k = j; k &gt;= i; k--) { dayMax = Math.max(dayMax, jobDifficulty[k]); cache[i][j] = Math.min(cache[i][j], cache[i - 1][k - 1] + dayMax); } } } return cache[d - 1][n - 1];}","link":"/2022/01/08/LeetCode-1335-Minimum-Difficulty-of-a-Job-Schedule/"},{"title":"LeetCode 155. Min Stack","text":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Example 1: 12345678910111213141516Input[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]Output[null,null,null,null,-3,null,0,-2]ExplanationMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); // return -3minStack.pop();minStack.top(); // return 0minStack.getMin(); // return -2 Constraints: -231 &lt;= val &lt;= 231 - 1 Methods pop, top and getMin operations will always be called on non-empty stacks. At most 3 * 104 calls will be made to push, pop, top, and getMin. Source: https://leetcode.com/problems/min-stack/ SolutionWe use a monotonic stack to maintain potential min elements in the future. Monotonic data structures are very effective in solving max/min problems. This solution can be further optimized. For example, we can replace mins with an object stack that contains &lt;value, times&gt;, so that we can save space when there are many mins with the same value. 1234567891011121314151617181920212223242526272829303132333435363738394041public class MinStack { private Deque&lt;Integer&gt; stack; // stack of candidate minimums // only keep candidates that can be the min after a series of operations private Deque&lt;Integer&gt; mins; public MinStack() { this.stack = new ArrayDeque&lt;&gt;(); this.mins = new ArrayDeque&lt;&gt;(); } public void push(int val) { stack.push(val); if (mins.isEmpty()) { mins.push(val); } else if (val &lt;= mins.peek()) { mins.push(val); } } // @pre: stack is not empty public void pop() { if (stack.isEmpty()) { return; } int val = stack.pop(); if (val == mins.peek()) { mins.pop(); } } // @pre: stack is not empty public int top() { return stack.peek().intValue(); } // @pre: stack is not empty public int getMin() { return mins.peek(); }}","link":"/2022/01/09/LeetCode-155-Min-Stack/"},{"title":"LeetCode 134. Gas Station","text":"QuestionThere are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Example 1: 12345678910Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2: 123456789Input: gas = [2,3,4], cost = [3,4,3]Output: -1Explanation:You can't start at station 0 or 1, as there is not enough gas to travel to the next station.Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can't travel around the circuit once no matter where you start. Constraints: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 Source: https://leetcode.com/problems/gas-station/ SolutionWe can abstract this problem as following: Given a delta array int[] delta, find a routine that sequentially traverses the array and makes the sum of $\\delta$ always above or equal to zero during traversal, and return the start index of this routine. If there is no such routine, return -1. There are two critical properities, we will prove and explain them later: If $\\sum_{i=0}^{n-1}{\\delta_i} \\ge0$, there must be at least one valid routine. If $\\sum_{i=p}^{q}{\\delta_i} &lt;0$ and $\\delta_p \\ge0$, any indice between $p$ and $q$ (inclusive) are not the start index of a valid routine. According to these two properties, we just need to traverse the array twice, one for checking whether a solution exists, the other for finding the first solution. Proof for the first property (Mathematical induction): Proof for the second property (better to understand by intuition): Note that just from the sum of the whole delta array, we cannot determine the number of solutions. Multiple solutions may exist when the sum is zero or greater than zero. For example, [1, 2, 3, 4] and [1, -1, 1, -1]. These two properties can also be used on many other situations. 1234567891011121314151617181920212223// two-pass, can be merged into one passpublic int canCompleteCircuit(int[] gas, int[] cost) { int len = gas.length; int totalTank = 0; // check if there is a solution for (int i = 0; i &lt; len; i++) { totalTank += gas[i] - cost[i]; } if (totalTank &lt; 0) { return -1; } // if solution exists, find a solution int currTank = 0; int startIndex = 0; for (int i = 0; i &lt; len; i++) { currTank += gas[i] - cost[i]; if (currTank &lt; 0) { // set i+1 as the start station and reset tank to zero startIndex = i + 1; currTank = 0; } } return startIndex;}","link":"/2021/12/29/LeetCode-134-Gas-Station/"},{"title":"LeetCode 271. Encode and Decode String","text":"QuestionDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: 1234string encode(vector&lt;string&gt; strs) { // ... your code return encoded_string;} Machine 2 (receiver) has the function: 1234vector&lt;string&gt; decode(string s) { //... your code return strs;} So Machine 1 does: 1string encoded_string = encode(strs); and Machine 2 does: 1vector&lt;string&gt; strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. You are not allowed to solve the problem using any serialize methods (such as eval). Example 1: 1234567891011Input: dummy_input = [&quot;Hello&quot;,&quot;World&quot;]Output: [&quot;Hello&quot;,&quot;World&quot;]Explanation:Machine 1:Codec encoder = new Codec();String msg = encoder.encode(strs);Machine 1 ---msg---&gt; Machine 2Machine 2:Codec decoder = new Codec();String[] strs = decoder.decode(msg); Example 2: 12Input: dummy_input = [&quot;&quot;]Output: [&quot;&quot;] Constraints: 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] contains any possible characters out of 256 valid ASCII characters. Source: https://leetcode.com/problems/encode-and-decode-strings/ SolutionThe best solution is to add a header that represents the length of each string instead of using delimiter. Strings will be concatenated as header-payload-header-.... Note that we call toCharArray method rather than getBytes(). We do not care about the content of payload so that we do not need to encode/decode strings. Also, on some OA platforms, we may need to import desired character set manually. 123456789101112131415161718192021222324252627282930313233343536373839404142// encode a 32-bit integer to a char array, according to little endian// then convert the byte array into a stringprivate String int2string(int len) { char[] bytes = new char[4]; for (int i = 0; i &lt; 4; i++) { bytes[i] = (char) ((len &gt;&gt; (i * 8)) &amp; 0xff); } return new String(bytes);}// decode a 32-bit string to intprivate int string2int(String s) { char[] bytes = s.toCharArray(); int len = 0; for (int i = 0; i &lt; 4; i++) { len += ((int) (bytes[i])) &lt;&lt; (i * 8); } return len;}// Encodes a list of strings to a single string.public String encode(List&lt;String&gt; strs) { StringBuilder builder = new StringBuilder(); for (String str : strs) { builder.append(int2string(str.length())); builder.append(str); } return builder.toString();}// Decodes a single string to a list of strings.public List&lt;String&gt; decode(String s) { int i = 0; List&lt;String&gt; res = new ArrayList&lt;&gt;(); while (i &lt; s.length()) { int strLen = string2int(s.substring(i, i + 4)); i += 4; res.add(s.substring(i, i + strLen)); i += strLen; } return res;}","link":"/2021/12/30/LeetCode-271-Encode-and-Decode-String/"},{"title":"LeetCode 3. Longest Substring Without Repeating Characters","text":"QuestionGiven a string s, find the length of the longest substring without repeating characters. Example 1: 123Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: s = &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: s = &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Constraints: 0 &lt;= s.length &lt;= 5 * 104 s consists of English letters, digits, symbols and spaces Source: https://leetcode.com/problems/longest-substring-without-repeating-characters/ SolutionSliding window is an optimization for brutal force search. When searching substrings that satisfy certain conditions, we do not have to examine every substring. In some cases, we can end up some search paths early and try another direction, which is similar to pruning in DFS. Take the following string as an example. It is meaningless to check substrings that start with ‘a’, ‘b’, ‘c’ and the first ‘5’ because they will definitely include repeating ‘5’ if they have a larger or the same length. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// brutal force, O(n^2)public int lengthOfLongestSubstring0(String s) { int len = s.length(); int maxSubLen = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); // i, j are the left and right end (inclusive) of a substring for (int i = 0; i &lt; len; i++) { for (int j = i; j &lt; len; j++) { char c = s.charAt(j); if (set.contains(c)) { break; } else { set.add(c); maxSubLen = Math.max(maxSubLen, j - i + 1); } } set.clear(); } return maxSubLen;}// sliding window, O(n)public int lengthOfLongestSubstring1(String s) { int len = s.length(); int maxSubLen = 0; int left = 0, right = 0; // character -&gt; frequency in the current substring Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (left &lt; len &amp;&amp; right &lt; len) { char cright = s.charAt(right); while (map.getOrDefault(cright, 0) &gt; 0) { char cleft = s.charAt(left); map.put(cleft, map.get(cleft) - 1); left++; } map.put(cright, 1); maxSubLen = Math.max(maxSubLen, right - left + 1); right++; } return maxSubLen;}// optimized sliding window, O(n)public int lengthOfLongestSubstring2(String s) { int len = s.length(); int maxSubLen = 0; int left = 0, right = 0; // character -&gt; last index of this character Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (left &lt; len &amp;&amp; right &lt; len) { char cright = s.charAt(right); if (map.containsKey(cright)) { // when left end moving forward, we do not remove kv pairs from map // only if the last index of cright is within the range of current substring // we move left forward left = Math.max(left, map.get(cright) + 1); } map.put(cright, right); maxSubLen = Math.max(maxSubLen, right - left + 1); right++; } return maxSubLen;}","link":"/2022/01/09/LeetCode-3-Longest-Substring-Without-Repeating-Characters/"},{"title":"LeetCode 696. Count Binary Substrings","text":"QuestionGive a binary string s, return the number of non-empty substrings that have the same number of 0‘s and 1‘s, and all the 0‘s and all the 1‘s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: 12345Input: s = &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: 123Input: s = &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1's and 0's. Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either '0' or '1'. Source: https://leetcode.com/problems/count-binary-substrings/ SolutionRepresent the string as groups of continuous 1s and 0s. The question requires “substrings”, which greatly simplifies the solution since characters in a substring must be continuous in the original string. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// group// Time Complexity: O(N), Space Complexity: O(N)public int countBinarySubstrings(String s) { // parameter validation if (s == null || s.length() &lt; 1) { return 0; } int len = s.length(); int[] group = new int[len]; int lastGroupIndex = 0; group[0] = 1; // get 0,1 distribution // [3, 2, 4, 1] for &quot;1110011110&quot; for (int i = 1; i &lt; len; i++) { if (s.charAt(i - 1) != s.charAt(i)) { lastGroupIndex++; group[lastGroupIndex] = 1; } else { group[lastGroupIndex]++; } } int result = 0; for (int i = 1; i &lt;= lastGroupIndex; i++) { result += Math.min(group[i - 1], group[i]); } return result;}// space optimized// like Fibonacci sequence// Time Complexity: O(N), Space Complexity: O(1)public int countBinarySubstrings2(String s) { // parameter validation if (s == null || s.length() &lt; 1) { return 0; } int len = s.length(); int result = 0, lastGroupNum = 0, currGroupNum = 1; for (int i = 1; i &lt; len; i++) { if (s.charAt(i - 1) != s.charAt(i)) { // update result at the start of a new group result += Math.min(lastGroupNum, currGroupNum); lastGroupNum = currGroupNum; currGroupNum = 1; } else { currGroupNum++; } } // handle corner case result += Math.min(lastGroupNum, currGroupNum); return result;}","link":"/2021/12/29/LeetCode-696-Count-Binary-Substrings/"},{"title":"LeetCode 718. Maximum Length of Repeated Subarray","text":"QuestionGiven two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays. Example 1: 123Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3,2,1]. Example 2: 12Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]Output: 5 Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 100 Source: https://leetcode.com/problems/maximum-length-of-repeated-subarray/ SolutionThe key idea of the transition equation is that a long common string (array) must contain short common strings (arrays). Thus, a long common string can be grown from a short common string. We simplify the searching process by searching common prefix num[i:], so that we only need to move one end of the string (array). Also, common suffix has the same effect. 1234567891011121314151617181920// DP, prefixpublic int findLength(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int maxCommonLen = 0; // dp[i][j] is the max length of common prefix of nums1[i:] and nums2[j:] // elements on the redundant row and column are initialized to zero, simplify the implementation int[][] dp = new int[len1 + 1][len2 + 1]; for (int i = len1 - 1; i &gt;= 0; i--) { for (int j = len2 - 1; j &gt;= 0; j--) { if (nums1[i] == nums2[j]) { dp[i][j] = dp[i + 1][j + 1] + 1; } else { dp[i][j] = 0; } maxCommonLen = Math.max(maxCommonLen, dp[i][j]); } } return maxCommonLen;}","link":"/2022/01/08/LeetCode-718-Maximum-Length-of-Repeated-Subarray/"},{"title":"OA Count Analogous Arrays","text":"QuestionAn array is said to be analogous to the secret array if all of the following conditions are true:• The length of the array is equal to the length of the secret array.• Each integer in the array lies in the interval [lowerBound, upperBound].• The difference between each pair of consecutive integers of the array must be equal to the difference between the respective pair of consecutive integers in the secret array. In other words, let the secret array be [s[0], s[1],…, s[n-1]] and let the analogous array be [a[0], a[1],…, a[n-1]], then (a[i-1] - a[i]) must be equal to (s[i-1] - s[i]) for each i from 1 to n -1. Given the value of integers lowerBound and upperBound, inclusive, and the array of differences between each pair of consecutive integers of the secret array, find the number of arrays that are analogous to the secret array. If there is no array analogous to the secret array, return 0. For example:consecutiveDifference = [-2, -1, -2, 5]lowerBound = 3upperBound = 10 Note that none of the values is out of the bound. All possible analogous arrays are:[3, 5, 6, 8, 3][4, 6, 7, 9, 4][5, 7, 8, 10, 5] Tha answer is 3. Source: https://leetcode.com/discuss/interview-question/1332322/amazon-online-assessment-july-2021-secret-array Solution123456789101112131415161718public static int countAnalogousArrays(int[] consecutiveDifference, int lowerBound, int upperBound) { // parameter validation if (consecutiveDifference == null || consecutiveDifference.length &lt; 1 || lowerBound &gt; upperBound) { return 0; } int delta = 0, maxDelta = 0, minDelta = 0; for (int i = 0; i &lt; consecutiveDifference.length; i++) { delta += consecutiveDifference[i]; maxDelta = Math.max(maxDelta, delta); minDelta = Math.min(minDelta, delta); } int maxDiff = maxDelta - minDelta, boundGap = upperBound - lowerBound; // max difference exceeds bound gap if (maxDiff &gt; boundGap) { return 0; } return boundGap - maxDiff;}","link":"/2021/12/29/OA-Count-Analogous-Arrays/"},{"title":"The C Programming Language Chapter-1","text":"Chapter-1 A Tutorial Introduction Notes of The C programming Language Integer Division of CIn C, integer division will truncate the result to zero, regardless of whether the result is positive or negative. printf Conversion Specification %fFor example, %6.4f means printf should print the value as floating point, at least 6 characters wide (it means the total width) and 4 after the decimal point. 123456789#include &lt;stdio.h&gt;int main() { float printFloatWidth1 = 1111.222; float printFloatWidth2 = 0.2; printf(&quot;printFloatWidth1: %6.4f\\n&quot;, printFloatWidth1); printf(&quot;printFloatWidth2: %6.2f\\n&quot;, printFloatWidth2); return 0;} 12printFloatWidth1: 1111.2220printFloatWidth2: 0.20 If the valid digits of the value cannot fill the least width, printf will fill it with spaces, as illustrated in printFloatWidth2. Symbolic Constants1#define PI 3.1415 Input and OutputC provides getchar() and putchar() as the user input/output interface. Comparing with InputStream and OutputStream in Java, input and output methods in C do not specify the source, destination and whether use buffer explicitly. getchar() and putchar() implicitly set console as input source and output destination, and enable buffer. It’s worth noting that \\n is not EOF. When we enter \\n in the terminal, the program will push the buffer (including \\n itself) to the while loop including getchar(). Then getchar() will read every character till the buffer is empty, and getchar() will block on it. Although the behaviors of this ‘echo’ program like it’s processing strings, it can only recognize characters one by one. A simple example 123456void copyInput() { int c; while ((c=getchar())!=EOF) { putchar(c); }} 1234567811145151451562365346236534 151 151 Declare functions in a compatible formatWe all know if you leave empty in the definition of C function argument list, it means this function need no argument. But for the compatibility with older C programs, it would be better to use void for an explicitly empty argument list. 12345678#include &lt;stdio.h&gt;int getLine(void);int copy(void);int main() { return 0;}","link":"/2021/12/10/The-C-Programming-Language-Chapter-1/"},{"title":"LeetCode 239. Sliding Window Maximum","text":"QuestionYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: 1234567891011Input: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [3,3,5,5,6,7]Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: 12Input: nums = [1], k = 1Output: [1] Constraints: 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length Source: https://leetcode.com/problems/sliding-window-maximum/ SolutionAs the window slides, we add a new element on right and discard an element on left. Because we discard elements from the window, we use a data structure to maintain all potential max values in the future (like LeetCode 155. Min Stack). Thus, we always push the new elment in to the queue when the window expands on right. If we find that the new element is greater than several previous elements, it means that the new element becomes the new “guardian”. The previous guardians that are smaller than this new guardian can be removed from the queue. Because they will be discarded eariler than the new guardian and will never become the max. In other words, elements with a larger index and a larger corresponding value have an overwhelming advantage in competing for max. The indexes in the monotonic queue are not necessarily consecutive. And this monotonic queue guarantees that these indexes are in ascending order and their corresponding elements in nums are in descending order. Because we need to repeatedly remove elements from the head and tail of the queue and append elements to the tail of the queue, we choose LinkedList as the instance class of our monotonic queue. 1234567891011121314151617181920212223242526272829303132// monotonic deque O(n)public int[] maxSlidingWindow2(int[] nums, int k) { int len = nums.length; int[] result = new int[len - k + 1]; // part indexes of elements in current window // i_{k}(max), i_{m}, i_{n}, ..., i_{right} // \\head i_{k} &lt; i_{m} &lt; i_{n} &lt; ... &lt; i_{right} \\tail // \\head nums[i_{k}] &gt;= nums[i_{m}] &gt;= nums[i_{n}] &gt;= ... &gt;= nums[i_{right}] \\tail Deque&lt;Integer&gt; monoDeque = new LinkedList&lt;&gt;(); // queue initialization with the first window for (int i = 0; i &lt; k; i++) { while (!monoDeque.isEmpty() &amp;&amp; nums[monoDeque.getLast()] &lt; nums[i]) { monoDeque.removeLast(); } monoDeque.addLast(i); } result[0] = nums[monoDeque.getFirst()]; int left = 1, right = k; for (; right &lt; len; left++, right++) { // max is to be removed if (!monoDeque.isEmpty() &amp;&amp; monoDeque.getFirst() == left - 1) { monoDeque.removeFirst(); } while (!monoDeque.isEmpty() &amp;&amp; nums[monoDeque.getLast()] &lt; nums[right]) { monoDeque.removeLast(); } monoDeque.addLast(right); result[left] = nums[monoDeque.getFirst()]; } return result;}","link":"/2022/01/09/LeetCode-239-Sliding-Window-Maximum/"},{"title":"LeetCode 862. Shortest Subarray with Sum at Least K","text":"QuestionGiven an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1. A subarray is a contiguous part of an array. Example 1: 12Input: nums = [1], k = 1Output: 1 Example 2: 12Input: nums = [1,2], k = 4Output: -1 Example 3: 12Input: nums = [2,-1,2], k = 3Output: 3 Constraints: 1 &lt;= nums.length &lt;= 105 -105 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= 109 Source: https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ SolutionWe use prefix sum to simplify the sum of subarray. The sum of any subarray can be calculated from prefix sum. This idea is similar to the usage of common prefix/suffix in LeetCode 718. Maximum Length of Repeated Subarray. We use a for loop to traverse ends of prefix sums prefixSums[y], a monotonic queue to maintain starts of prefix sums prefixSums[x]. For valid combinations of prefix sums (i.e. prefixSums[y]-prefixSums[x]&gt;=k), smaller y, larger x and larger prefixSums[x] have advantage. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 2D DP, O(n^2), Memory Limit Exceeded// still has redundant computationpublic int shortestSubarray(int[] nums, int k) { int len = nums.length; int minLen = len + 1; // dp[i][j] is the sum of subarray nums[i:j] (both ends are inclusive) int[][] dp = new int[len][len]; for (int m = 0; m &lt; len; m++) { dp[m][m] = nums[m]; if (dp[m][m] &gt;= k) { // can also return early minLen = Math.min(minLen, 1); } } for (int i = 0; i &lt; len; i++) { for (int j = i + 1; j &lt; len; j++) { dp[i][j] = dp[i][j - 1] + nums[j]; // repeat same computation if (dp[i][j] &gt;= k) { minLen = Math.min(minLen, j - i + 1); } } } return minLen == len + 1 ? -1 : minLen;}// monotonic queue, O(n)public int shortestSubarray2(int[] nums, int k) { int len = nums.length; int minLen = len + 1; // prefixSums[i] is the sum of nums[:i] (exclusive) long[] prefixSums = new long[len + 1]; // calculate prefix sum for (int i = 1; i &lt;= len; i++) { prefixSums[i] = prefixSums[i - 1] + nums[i - 1]; } // mono-dequeue, each element is the index of prefixSums, // prefixSums[i] ascending Deque&lt;Integer&gt; monoDeque = new LinkedList&lt;&gt;(); // sum of subarray nums[x:y] (x inclusive, y exclusive) = prefixSums[y] - prefixSums[x] for (int y = 0; y &lt;= len; y++) { while (!monoDeque.isEmpty() &amp;&amp; prefixSums[y] - prefixSums[monoDeque.getFirst()] &gt;= k) { int x = monoDeque.removeFirst(); minLen = Math.min(minLen, y - x); } while (!monoDeque.isEmpty() &amp;&amp; prefixSums[y] &lt;= prefixSums[monoDeque.getLast()]) { monoDeque.removeLast(); } monoDeque.addLast(y); } return minLen == len + 1 ? -1 : minLen;}","link":"/2022/01/09/LeetCode-862-Shortest-Subarray-with-Sum-at-Least-K/"},{"title":"LeetCode 76. Minimum Window Substring","text":"QuestionGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &quot;&quot;. The testcases will be generated such that the answer is unique. A substring is a contiguous sequence of characters within the string. Example 1: 123Input: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;Output: &quot;BANC&quot;Explanation: The minimum window substring &quot;BANC&quot; includes 'A', 'B', and 'C' from string t. Example 2: 123Input: s = &quot;a&quot;, t = &quot;a&quot;Output: &quot;a&quot;Explanation: The entire string s is the minimum window. Example 3: 1234Input: s = &quot;a&quot;, t = &quot;aa&quot;Output: &quot;&quot;Explanation: Both 'a's from t must be included in the window.Since the largest window of s only has one 'a', return empty string. Constraints: m == s.length n == t.length 1 &lt;= m, n &lt;= 105 s and t consist of uppercase and lowercase English letters. Source: https://leetcode.com/problems/minimum-window-substring/ SolutionWe first expand the right end of the window to find a valid window. Then we shrink the left end to find a candidate min window. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// sliding window, Time complexity O(s.length() + t.length())public String minWindow(String s, String t) { int tLen = t.length(); int sLen = s.length(); int minWindowLen = sLen + 1; // two ends of the window with min length, both inclusive int minWindowLeft = 0, minWindowRight = 0; int left = 0, right = 0; // the dictionary that describes characters to be included in desired window Map&lt;Character, Integer&gt; dict = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; wordCount = new HashMap&lt;&gt;(); for (int i = 0; i &lt; tLen; i++) { char c = t.charAt(i); dict.put(c, dict.getOrDefault(c, 0) + 1); } // number of requirements to meet int toMeet = dict.size(); while (left &lt; sLen &amp;&amp; right &lt; sLen) { char c = s.charAt(right); if (dict.containsKey(c)) { wordCount.put(c, wordCount.getOrDefault(c, 0) + 1); if (wordCount.get(c).intValue() == dict.get(c).intValue()) { toMeet--; } // valid window while (toMeet == 0) { // check and record current min window if (right - left + 1 &lt; minWindowLen) { minWindowLen = right - left + 1; minWindowLeft = left; minWindowRight = right; } // shrink window char cRemove = s.charAt(left); if (dict.containsKey(cRemove)) { wordCount.put(cRemove, wordCount.get(cRemove) - 1); if (wordCount.get(cRemove) &lt; dict.get(cRemove)) { toMeet++; } } left++; } } // invalid window, expand right end right++; } return minWindowLen == sLen + 1 ? &quot;&quot; : s.substring(minWindowLeft, minWindowRight + 1);}","link":"/2022/01/09/LeetCode-76-Minimum-Window-Substring/"},{"title":"LeetCode 1044. Longest Duplicate Substring","text":"QuestionGiven a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap. Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is &quot;&quot;. Example 1: 12Input: s = &quot;banana&quot;Output: &quot;ana&quot; Example 2: 12Input: s = &quot;abcd&quot;Output: &quot;&quot; Constraints: 2 &lt;= s.length &lt;= 3 * 104 s consists of lowercase English letters. Source: https://leetcode.com/problems/longest-duplicate-substring/ SolutionOne intuitive idea is 2D DP, which has a O(n^2) time complexity. Finding duplicate substring in one string can be regarded as a variant of the problem of finding common substrings between two strings, like LeetCode 718. Maximum Length of Repeated Subarray. How to solve this problem faster? The key point is how to determine whether two substring are identical. To prove that two substring are identical, we have to compare their characters one by one. However, we do not have to do so to be sure that two substring are not identical. Instead, if the hash values of two substrings are not the same, these two substrings must be different. Computing the hash value of each substring is still time consuming. We use rolling hash function, which treats character in a string as digits and takes the numeric value of these digits as the hash value. Thus, for a new string that only changes a few characters (in this problem, the first and the last), rolling hash function can compute the new hash value quickly. In the rolling hash function, we use a large prime number 10^9+7 to avoid overflow. A long duplicate string must contain shorter duplicate strings. Also, we only care about the longest duplicate substring. We can use binary search to find the largest length of duplicate substring. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @param L length of duplicate strings * @param base base of numeric strings * @param N length of the original string * @param nums numeric array of the original string * @return the start index of a duplicate string, if not exist, return -1 */private int searchDuplicateStrings(int L, int base, long modulus, int N, int[] nums) { long hash = 0; // hash code long highest = 1; // base^(L-1) for (int i = 0; i &lt; L; i++) { hash = (hash * base + nums[i]) % modulus; } for (int i = 1; i &lt; L; i++) { highest = (highest * base) % modulus; } // hash code -&gt; a list of start indexes Map&lt;Long, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // add the first substring map.put(hash, new ArrayList&lt;&gt;()); map.get(hash).add(0); for (int left = 1; left &lt;= N - L; left++) { // update hash value while avoiding overflow hash = (hash - nums[left - 1] * highest % modulus + modulus) % modulus; hash = (hash * base + nums[left + L - 1]) % modulus; if (map.containsKey(hash)) { List&lt;Integer&gt; starts = map.get(hash); // compare substrings with the same hash code for (int start : starts) { boolean isSame = true; for (int i = 0; i &lt; L; i++) { if (nums[i + left] != nums[i + start]) { isSame = false; break; } } if (isSame) { return left; } } starts.add(left); } else { map.put(hash, new ArrayList&lt;&gt;()); map.get(hash).add(left); } } return -1;}// average O(nlog(n))public String longestDupSubstring(String s) { int sLen = s.length(); int[] nums = new int[sLen]; // modulus for rolling hash function // a large prime number that fits into 32-bit integer final long modulus = (long) Math.pow(10, 9) + 7; // base of numeric strings final int a = 26; for (int i = 0; i &lt; sLen; i++) { nums[i] = s.charAt(i) - 'a'; } // binary search int low = 1, high = sLen; int resultLen = 0, resultIndex = -1; while (low &lt;= high) { int mid = low + (high - low) / 2; int index = searchDuplicateStrings(mid, a, modulus, sLen, nums); if (index == -1) { // no duplicate substrings with length of mid high = mid - 1; } else { // duplicate substrings with length of mid exist resultIndex = index; resultLen = mid; low = mid + 1; } } return resultLen == 0 ? &quot;&quot; : s.substring(resultIndex, resultIndex + resultLen);}","link":"/2022/01/10/LeetCode-1044-Longest-Duplicate-Substring/"},{"title":"Coding Math","text":"Modular arithmetic$a\\equiv b\\space(\\text{mod}\\space n)$ means a mod n = b mod n. The parentheses mean that $(\\text{mod}\\space n)$ applies to the entire equation, not just to the right-hand side. Reflexivity, Symmetry and Transitivity: $a\\equiv a\\space(\\text{mod}\\space n)$ $a\\equiv b\\space(\\text{mod}\\space n) \\Leftrightarrow b\\equiv a\\space(\\text{mod}\\space n)$ If $a\\equiv b\\space(\\text{mod}\\space n)$ and $b\\equiv c\\space(\\text{mod}\\space n)$, then $a\\equiv c\\space(\\text{mod}\\space n)$ If $a_1\\equiv b_1\\space(\\text{mod}\\space n)$ and $a_2\\equiv b_2\\space(\\text{mod}\\space n)$, or if $a\\equiv b\\space(\\text{mod}\\space n)$, then: $a+k\\equiv b+k\\space(\\text{mod}\\space n)$, for any integer $k$ $ka\\equiv kb\\space(\\text{mod}\\space n)$, for any integer $k$ $a_1+a_2\\equiv b_1+b_2\\space(\\text{mod}\\space n)$ $a_1-a_2\\equiv b_1-b_2\\space(\\text{mod}\\space n)$ $a_1a_2\\equiv b_1b_2\\space(\\text{mod}\\space n)$ $a^k\\equiv b^k\\space(\\text{mod}\\space n)$, for any non-negative integer $k$ $p(a)\\equiv p(b)\\space(\\text{mod}\\space n)$, for any polynomial $p(x)$ with integer coefficients Compatibility with translation, scaling, addition, subtraction, multiplication, exponentiation and polynomial evaluation.","link":"/2022/01/10/Coding-Math/"},{"title":"LeetCode 56. Merge Intervals","text":"QuestionGiven an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: 123Input: intervals = [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: intervals = [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 Source: https://leetcode.com/problems/merge-intervals/ SolutionFor interval problems, sorting the interval array by start is usually a cracking direction. For sorted interval array, if prev.end &lt; curr.start, there is no overlap between these two intervals Otherwise, they are overlapped. 12345678910111213141516171819202122public int[][] merge(int[][] intervals) { // sort by the start in ascending order Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); Deque&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); merged.add(intervals[0]); for (int[] interval : intervals) { int[] last = merged.getLast(); if (last[1] &lt; interval[0]) { merged.addLast(interval); } else { // merge last[1] = Math.max(last[1], interval[1]); } } int[][] result = new int[merged.size()][]; merged.toArray(result); return result;}","link":"/2022/01/12/LeetCode-56-Merge-Intervals/"},{"title":"LeetCode 378. Kth Smallest Element in a Sorted Matrix","text":"QuestionGiven an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n^2). Example 1: 123Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8Output: 13Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 Example 2: 12Input: matrix = [[-5]], k = 1Output: -5 Constraints: n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 300 -109 &lt;= matrix[i][j] &lt;= 109 All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order. 1 &lt;= k &lt;= n2 Source: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ SolutionGenerally, there are three ways to find the kth smallest/largest element: 1. Max Heap 2. Min Heap 3. Quick Sort. We will skip quicksort for now in this blog post. If using max heap, we should instantiate a max heap with size of k, and fill the heap with the first k elements of the matrix (it is the initilization process). Then we traverse the rest of elements in the matrix. If an element e is greater than the heap top, drop it; otherwise, pop the heap top and push element e. After this process, elements in the max heap are k-smallest elements. And the heap top is the result. However, because we need to traverse the whole matrix (can be optimized but still on the order of O(n^2)) and do not utilize the order feature of given matrix, the time complexity will be O(n^2*log(k)). In the other solution, we treat a sorted matrix as n sorted list. So it can be regarded as an extension of finding kth smallest element in two sorted list. The difference is that we do not use n variables to store indexes on list and compare them, but use a min heap to do this job. The main difference between max heap solution and min heap solution: We use the max heap to find k-smallest elements by traverse the matrix and comparing elements with the heap top. For min heap, we get k-smallest elements by other means and use min heap to find largest one of them (the kth smallest element). 1234567891011121314151617181920212223242526272829303132333435363738class element { // matrix[x][y] int val; int x; int y; public element(int _val, int _x, int _y) { this.val = _val; this.x = _x; this.y = _y; }}// min heap, Time Complexity O(k*log(k))public int kthSmallest2(int[][] matrix, int k) { int n = matrix.length; int numSortedRow = Math.min(n, k); PriorityQueue&lt;element&gt; minHeap = new PriorityQueue&lt;&gt;(numSortedRow, new Comparator&lt;element&gt;() { @Override public int compare(element o1, element o2) { return o1.val - o2.val; } }); for (int i = 0; i &lt; numSortedRow; i++) { minHeap.add(new element(matrix[i][0], i, 0)); } int result = 0; // treat a sorted matrix as n sorted lists for (int count = 0; count &lt; k; count++) { element e = minHeap.poll(); result = e.val; if (e.y &lt; n - 1) { minHeap.add(new element(matrix[e.x][e.y + 1], e.x, e.y + 1)); } } return result;}","link":"/2022/01/18/LeetCode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/"},{"title":"LeetCode 121. Best Time to Buy and Sell Stock","text":"QuestionYou are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: 1234Input: prices = [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: 123Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 Source: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ SolutionThe best time to buy and sell can be interpreted as two forms: the lowest price we have ever seen to buy + current price to sell current price to buy + the highest price in the future to sell To solve these problems of a flexible window, one key point is to get a reliable value of one end first and traverse the other end. In the following implementation, we choose the first form so we traverse the array from the left to the right. 1234567891011121314public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int maxProfit = 0; // min price that has been seen int minPrice = Integer.MAX_VALUE; for (int price : prices) { minPrice = Math.min(minPrice, price); // the max profit if selling the stock on the ith day maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit;}","link":"/2022/01/18/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock/"},{"title":"LeetCode 123. Best Time to Buy and Sell Stock III","text":"QuestionYou are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: 1234Input: prices = [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: 1234Input: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. Constraints: 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 Source: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ SolutionleftProfits[i] means the max profit of all transactions in prices[:i] (they can sell on day i or earlier). Similar for rightProfits[i]. The overlap point of day i for leftProfits[i] and rightProfits[i] is necessary. Because the question requires a result with at most two transactions. The overlap point can help two transactions to be merged into one. We find seen min price and max price from two different ends to fill two cache arrays. 1234567891011121314151617181920212223242526public int maxProfit(int[] prices) { if (prices == null || prices.length &lt;= 1) { return 0; } int len = prices.length; // leftProfits[i] is the max profit of the first transaction in prices[:i] (inclusive) // rightProfits[i] is the max profit of the second transaction in prices[i:] (inclusive) // when two transactions overlap on i, they can be merged into one int[] leftProfits = new int[len]; int[] rightProfits = new int[len]; int leftMin = prices[0]; int rightMax = prices[len - 1]; // k is the distance to the end, to merge two loops into one for (int k = 1; k &lt; len; k++) { int l = k, r = len - 1 - k; leftMin = Math.min(leftMin, prices[l]); rightMax = Math.max(rightMax, prices[r]); leftProfits[l] = Math.max(leftProfits[l - 1], prices[l] - leftMin); rightProfits[r] = Math.max(rightProfits[r + 1], rightMax - prices[r]); } int maxProfit = 0; for (int i = 0; i &lt; len; i++) { maxProfit = Math.max(maxProfit, leftProfits[i] + rightProfits[i]); } return maxProfit;}","link":"/2022/01/18/LeetCode-123-Best-Time-to-Buy-and-Sell-Stock-III/"},{"title":"LeetCode 188. Best Time to Buy and Sell Stock IV","text":"QuestionYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: 123Input: k = 2, prices = [2,4,1]Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: 123Input: k = 2, prices = [3,2,6,5,0,3]Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints: 0 &lt;= k &lt;= 100 0 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 Source: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ SolutionTo find an efficient solution for this type of problem, we need to use DP. However, let us consider an extreme case fisrt. We are allow to make at most k transactions. If k is large enough to enable us to grab every profit, we do not have to do DP but just traverse the array once. The threshold of this k is n/2. Because a stock can rise at most n/2 times (two rises on two adjacent days can be merged into one). This is the idea of quickSolve(). For DP, the essence of DP is to solve small sub-problems first, and derive the results from these small sub-problem to larger problems. This max profit problem has two dimensions: 1. the number of days; 2. the max number of transactions allowed. So we creaste a 2D DP cache. And because deriving results from fewer days to more days is easier than changing max number of transactions, we make k+1 (more convenient than k) the first dimension and n the second dimension. Always use a variable that is easier to derive as the second dimension in 2D DP. dp[i][j] represents the max profit of prices[:j] (inclusive) with at most i transactions. Thus, there are only two options for dp[i][j]: sell the stock on jth day or not. If sell, we need to iterate all possible cases to find the max profit. If not, dp[i][j] should be equal to dp[i][j-1]. So, we can get the following formulas for these two situations: dp[i][j] = dp[i][j-1]. t is the date the last transaction was brought. dp[i][j] = for t: 0-&gt;j-1, max(dp[i-1][t-1]+prices[j]-prices[t]) . This solution still has a O((n^2)*k) time complexity. The bottleneck is the second formula. However, we can further optimize it. It is equivalent to for t: 0-&gt;j-1, max(dp[i-1][t-1]-prices[t])+prices[j]. Thus, we can find the max of the second formula while iterating 0 to j-1 once. Finally, the time complexity is optimized to O(nk). 1234567891011121314151617181920212223242526272829// return the max profit without limiting the number of transactionsprivate int quickSolve(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { // short-term trading maxProfit += Math.max(0, prices[i] - prices[i - 1]); } return maxProfit;}// Time Complexity O(nk)public int maxProfit(int k, int[] prices) { int n = prices.length; // if k allows us to get every profit if (k &gt;= n / 2) { return quickSolve(prices); } // dp[i][j] is the max profit of prices[:j] (inclusive) with at most i transactions int[][] dp = new int[k + 1][n]; for (int i = 1; i &lt;= k; i++) { // dp[i-1][t-1]-prices[t] int maxTemp = -prices[0]; for (int j = 1; j &lt; n; j++) { dp[i][j] = Math.max(dp[i][j - 1], maxTemp + prices[j]); maxTemp = Math.max(maxTemp, dp[i - 1][j - 1] - prices[j]); } } return dp[k][n - 1];}","link":"/2022/01/24/LeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV/"},{"title":"LeetCode 252. Meeting Rooms","text":"QuestionGiven an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings. Example 1: 12Input: intervals = [[0,30],[5,10],[15,20]]Output: false Example 2: 12Input: intervals = [[7,10],[2,4]]Output: true Constraints: 0 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt; endi &lt;= 106 Source: https://leetcode.com/problems/meeting-rooms/ SolutionSort intervals by start. 12345678910111213141516// sort, O(nlog(n))public boolean canAttendMeetings(int[][] intervals) { // sort intervals by the start in ascending order Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i - 1][1] &gt; intervals[i][0]) { return false; } } return true;}","link":"/2022/01/24/LeetCode-252-Meeting-Rooms/"},{"title":"LeetCode 253. Meeting Rooms II","text":"QuestionGiven an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required. Example 1: 12Input: intervals = [[0,30],[5,10],[15,20]]Output: 2 Example 2: 12Input: intervals = [[7,10],[2,4]]Output: 1 Constraints: 1 &lt;= intervals.length &lt;= 104 0 &lt;= starti &lt; endi &lt;= 106 Source: https://leetcode.com/problems/meeting-rooms-ii/ SolutionWe can simulate the schedule of meeting rooms by a min heap of ends of intervals. Because when a new meeting comes in, we only need to compare its start time with the end time of the earliest ending meeting, and decide whether we should add one more room. Note that in the following implementation, we poll at most one element from the heap per loop, rather than polling all terminated meetings, because we choose return the size of the heap as the result. Logically chronological ordering solution is further optimized, though its time complexity is the same heap-based solution, O(nlog(n)). The idea is break the relationship between start and end. We sort starts and ends separately, and use two pointers to traverse them. We can still get the correct result because we do not care about which meeting ends and makes a room spare, but the timepoint of the end. One evidence is that in the heap-based solution, we only stores ends of intervals in the heap. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// heap, O(nlog(n))public int minMeetingRooms(int[][] intervals) { if (intervals.length == 0) { return 0; } // sort intervals by the start in ascending order Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); // min heap of end of interval PriorityQueue&lt;Integer&gt; endMinHeap = new PriorityQueue&lt;&gt;(intervals.length, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); endMinHeap.add(intervals[0][1]); for (int i = 1; i &lt; intervals.length; i++) { int[] curr = intervals[i]; // try to find a free room if (curr[0] &gt;= endMinHeap.peek()) { endMinHeap.poll(); } endMinHeap.add(curr[1]); } return endMinHeap.size();}// Chronological Ordering, O(nlog(n))public int minMeetingRooms2(int[][] intervals) { int len = intervals.length; if (len == 0) { return 0; } int[] starts = new int[len]; int[] ends = new int[len]; for (int i = 0; i &lt; len; i++) { starts[i] = intervals[i][0]; ends[i] = intervals[i][1]; } // sort respectively by ascending order // we want to know if there is an empty room at a certain point in time, // but don't care which meeting room it is Arrays.sort(starts); Arrays.sort(ends); int startIndex = 0, endIndex = 0; int numRoom = 0; while (startIndex &lt; len &amp;&amp; endIndex &lt; len) { if (starts[startIndex] &gt;= ends[endIndex]) { startIndex++; endIndex++; } else { startIndex++; numRoom++; } } return numRoom;}","link":"/2022/01/24/LeetCode-253-Meeting-Rooms-II/"},{"title":"LeetCode 452. Minimum Number of Arrows to Burst Balloons","text":"QuestionThere are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons. Example 1: 12345Input: points = [[10,16],[2,8],[1,6],[7,12]]Output: 2Explanation: The balloons can be burst by 2 arrows:- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. Example 2: 123Input: points = [[1,2],[3,4],[5,6],[7,8]]Output: 4Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. Example 3: 12345Input: points = [[1,2],[2,3],[3,4],[4,5]]Output: 2Explanation: The balloons can be burst by 2 arrows:- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. Constraints: 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 Source: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// sort by end, greedy, Time Complexity O(nlog(n))public int findMinArrowShots(int[][] points) { if (points == null || points.length == 0) { return 0; } // sort by end in ascending order Arrays.sort(points, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // in case of overflow if (o1[1] == o2[1]) { return 0; } else if (o1[1] &gt; o2[1]) { return 1; } else { return -1; } } }); int prevEnd = points[0][1]; int numArrow = 1; for (int[] point : points) { if (point[0] &gt; prevEnd) { // no overlap numArrow++; prevEnd = point[1]; } } return numArrow;}// sort by start, greedy, Time Complexity O(nlog(n))public int findMinArrowShots2(int[][] points) { if (points == null || points.length == 0) { return 0; } // sort by start in ascending order Arrays.sort(points, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // in case of overflow if (o1[0] == o2[0]) { return 0; } else if (o1[0] &gt; o2[0]) { return 1; } else { return -1; } } }); int minEnd = points[0][1]; int numArrow = 1; for (int[] point : points) { if (point[0] &gt; minEnd) { // no overlap numArrow++; minEnd = point[1]; } else { minEnd = Math.min(minEnd, point[1]); } } return numArrow;}","link":"/2022/01/25/LeetCode-452-Minimum-Number-of-Arrows-to-Burst-Balloons/"},{"title":"LeetCode 435. Non-overlapping Intervals","text":"QuestionGiven an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Example 1: 123Input: intervals = [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping. Example 2: 123Input: intervals = [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping. Example 3: 123Input: intervals = [[1,2],[2,3]]Output: 0Explanation: You don't need to remove any of the intervals since they're already non-overlapping. Constraints: 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 Source: https://leetcode.com/problems/non-overlapping-intervals/ Solution1234567891011121314151617181920212223242526272829// sort by start, greedy, Time Complexity O(nlog(n))public int eraseOverlapIntervals(int[][] intervals) { if (intervals == null || intervals.length == 0) { return 0; } Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); int numRemove = 0; int prevEnd = intervals[0][1]; for (int i = 1; i &lt; intervals.length; i++) { int[] curr = intervals[i]; if (curr[0] &gt;= prevEnd) { // no overlap prevEnd = curr[1]; } else if (prevEnd &lt; curr[1]) { // intersection overlap // remove current interval // do not change prevEnd numRemove++; } else { // included overlap // remove previous interval numRemove++; prevEnd = curr[1]; } } return numRemove;}","link":"/2022/01/25/LeetCode-435-Non-overlapping-Intervals/"},{"title":"LeetCode 616. Add Bold Tag in String","text":"QuestionYou are given a string s and an array of strings words. You should add a closed pair of bold tag &lt;b&gt; and &lt;/b&gt; to wrap the substrings in s that exist in words. If two such substrings overlap, you should wrap them together with only one pair of closed bold-tag. If two substrings wrapped by bold tags are consecutive, you should combine them. Return s after adding the bold tags. Example 1: 12Input: s = &quot;abcxyz123&quot;, words = [&quot;abc&quot;,&quot;123&quot;]Output: &quot;&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;&quot; Example 2: 12Input: s = &quot;aaabbcc&quot;, words = [&quot;aaa&quot;,&quot;aab&quot;,&quot;bc&quot;]Output: &quot;&lt;b&gt;aaabbc&lt;/b&gt;c&quot; Constraints: 1 &lt;= s.length &lt;= 1000 0 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 1000 s and words[i] consist of English letters and digits. All the values of words are unique. Source: https://leetcode.com/problems/add-bold-tag-in-string/ SolutionConvert this problem to a merge interval problem. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Interval { public int start; // inclusive public int end; // exclusive public Interval(int s, int e) { this.start = s; this.end = e; }}private List&lt;Interval&gt; mergeIntervals(List&lt;Interval&gt; intervals) { if (intervals == null || intervals.size() == 0) { return new LinkedList&lt;Interval&gt;(); } // sort intervals by start in ascending order Collections.sort(intervals, new Comparator&lt;Interval&gt;() { @Override public int compare(Interval o1, Interval o2) { return o1.start - o2.start; } }); LinkedList&lt;Interval&gt; merged = new LinkedList&lt;&gt;(); int size = intervals.size(); merged.add(intervals.get(0)); for (int i = 1; i &lt; size; i++) { Interval curr = intervals.get(i); Interval last = merged.getLast(); if (curr.start &gt; last.end) { // no overlap merged.add(curr); } else { last.end = Math.max(last.end, curr.end); } } return merged;}public String addBoldTag(String s, String[] words) { List&lt;Interval&gt; intervals = new ArrayList&lt;&gt;(); for (String pattern : words) { int plen = pattern.length(); int index = s.indexOf(pattern, -1); while (index != -1) { intervals.add(new Interval(index, index + plen)); index = s.indexOf(pattern, index + 1); } } List&lt;Interval&gt; merged = mergeIntervals(intervals); StringBuilder builder = new StringBuilder(); int prevEnd = 0; for (Interval interval : merged) { builder.append(s.substring(prevEnd, interval.start)); builder.append(&quot;&lt;b&gt;&quot;); builder.append(s.substring(interval.start, interval.end)); builder.append(&quot;&lt;/b&gt;&quot;); prevEnd = interval.end; } builder.append(s.substring(prevEnd, s.length())); return builder.toString();}","link":"/2022/01/25/LeetCode-616-Add-Bold-Tag-in-String/"},{"title":"LeetCode 759. Employee Free Time","text":"QuestionWe are given a list schedule of employees, which represents the working time for each employee. Each employee has a list of non-overlapping Intervals, and these intervals are in sorted order. Return the list of finite intervals representing common, positive-length free time for all employees, also in sorted order. (Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays. For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined). Also, we wouldn’t include intervals like [5, 5] in our answer, as they have zero length. Example 1: 12345Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]Output: [[3,4]]Explanation: There are a total of three employees, and all commonfree time intervals would be [-inf, 1], [3, 4], [10, inf].We discard any intervals that contain inf as they aren't finite. Example 2: 12Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]Output: [[5,6],[7,9]] Constraints: 1 &lt;= schedule.length , schedule[i].length &lt;= 50 0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8 Source: https://leetcode.com/problems/employee-free-time/ SolutionWhat we need to return is the common free times for all employees. Thus, the identity of employees does not matter. We can flatten schedule into a 1D list and sort it by start. Then we can solve this problem with the same idea as LeetCode 56. Merge Intervals. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Interval { public int start; public int end; public Interval() { } public Interval(int _start, int _end) { start = _start; end = _end; }}public List&lt;Interval&gt; employeeFreeTime(List&lt;List&lt;Interval&gt;&gt; schedule) { // contains all intervals List&lt;Interval&gt; timeline = new ArrayList&lt;&gt;(); for (List&lt;Interval&gt; list : schedule) { timeline.addAll(list); } // sort by start in ascending order Collections.sort(timeline, new Comparator&lt;Interval&gt;() { @Override public int compare(Interval o1, Interval o2) { return o1.start - o2.start; } }); int len = timeline.size(); List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if (len == 0) { return result; } int prevEnd = timeline.get(0).end; // each common interval is defined by the largest previous end and the smallest next start for (int i = 1; i &lt; len; i++) { Interval curr = timeline.get(i); if (curr.start &gt; prevEnd) { // no overlap result.add(new Interval(prevEnd, curr.start)); prevEnd = curr.end; } else { // overlap prevEnd = Math.max(prevEnd, curr.end); } } return result;}","link":"/2022/01/25/LeetCode-759-Employee-Free-Time/"},{"title":"LeetCode 57. Insert Interval","text":"QuestionYou are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: 12Input: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]] Example 2: 123Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: 0 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 105 intervals is sorted by starti in ascending order. newInterval.length == 2 0 &lt;= start &lt;= end &lt;= 105 Source: https://leetcode.com/problems/insert-interval/ Solution1234567891011121314151617181920212223242526272829303132333435public int[][] insert(int[][] intervals, int[] newInterval) { int start = newInterval[0]; int end = newInterval[1]; int index = 0; int len = intervals.length; Deque&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); // no overlap while (index &lt; len) { if (intervals[index][1] &lt; start) { merged.addLast(intervals[index]); index++; } else { break; } } // merge while (index &lt; len) { if (intervals[index][0] &lt;= end) { start = Math.min(start, intervals[index][0]); end = Math.max(end, intervals[index][1]); index++; } else { break; } } merged.addLast(new int[]{start, end}); // no overlap while (index &lt; len) { merged.addLast(intervals[index]); index++; } int[][] result = new int[merged.size()][]; merged.toArray(result); return result;}","link":"/2022/01/25/LeetCode-57-Insert-Interval/"},{"title":"LeetCode 102. Binary Tree Level Order Traversal","text":"QuestionGiven the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). Example 1: 12Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]] Example 2: 12Input: root = [1]Output: [[1]] Example 3: 12Input: root = []Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &lt;= Node.val &lt;= 1000 Source: https://leetcode.com/problems/binary-tree-level-order-traversal/ SolutionUse queue size in BFS to implement layer-ordre traversal of a tree. 123456789101112131415161718192021222324252627282930313233343536373839404142class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }}public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if (root != null) { queue.add(root); } while (!queue.isEmpty()) { List&lt;Integer&gt; currLevel = new ArrayList&lt;&gt;(); int numThisLevel = queue.size(); for (int i = 0; i &lt; numThisLevel; i++) { TreeNode curr = queue.poll(); currLevel.add(curr.val); if (curr.left != null) { queue.add(curr.left); } if (curr.right != null) { queue.add(curr.right); } } result.add(currLevel); } return result;}","link":"/2022/01/25/LeetCode-102-Binary-Tree-Level-Order-Traversal/"},{"title":"LeetCode 785. Is Graph Bipartite?","text":"QuestionThere is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite. Example 1: 123Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]Output: falseExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. Example 2: 123Input: graph = [[1,3],[0,2],[1,3],[0,2]]Output: trueExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. Constraints: graph.length == n 1 &lt;= n &lt;= 100 0 &lt;= graph[u].length &lt; n 0 &lt;= graph[u][i] &lt;= n - 1 graph[u] does not contain u. All the values of graph[u] are unique. If graph[u] contains v, then graph[v] contains u. Source: https://leetcode.com/problems/is-graph-bipartite/ SolutionA graph is bipartite means that for each node in that graph, its neighbors and itself should be in two different groups. 123456789101112131415161718192021222324252627282930313233// BFS + coloring, Time Complexity O(|V|+|E|)public boolean isBipartite(int[][] graph) { // number of nodes int N = graph.length; // node ID -&gt; color, 1 red, -1 blue Map&lt;Integer, Integer&gt; colorMap = new HashMap&lt;&gt;(); // queue for bfs Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int id = 0; id &lt; N; id++) { // to handle forest if (!colorMap.containsKey(id)) { colorMap.put(id, 1); // group to red by default // BFS queue.add(id); while (!queue.isEmpty()) { int tid = queue.poll(); int tcolor = colorMap.get(tid); for (int nid : graph[tid]) { // visit neighbors if (colorMap.containsKey(nid)) { int ncolor = colorMap.get(nid); if (ncolor == tcolor) { return false; } } else { // color the neighbor with the opposite color colorMap.put(nid, -tcolor); queue.add(nid); } } } } } return true;}","link":"/2022/01/25/LeetCode-785-Is-Graph-Bipartite/"},{"title":"LeetCode 55. Jump Game","text":"QuestionYou are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Example 1: 123Input: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 123Input: nums = [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 105 Source: https://leetcode.com/problems/jump-game/ SolutionThe optimization idea is quite similar to finding Fibonacci number. For the current point, we only care about whether we can get to a point that can reach the end. Thus, we only need to maintain the index of left most point that can reach the end. 12345678910111213141516171819202122232425262728293031323334353637383940// DP, Time Complexity O(n^2)public boolean canJump(int[] nums) { if (nums == null || nums.length == 0) { return false; } int len = nums.length; // dp[i] represents the quality of index i. // 1, -1, 0 means can reach the end, cannot reach the end and unknown respectively // in fact, a visited index with value of 0 can also be regarded as -1 int[] dp = new int[len]; dp[len - 1] = 1; for (int i = len - 2; i &gt;= 0; i--) { int maxStep = nums[i]; for (int k = 0; k &lt;= maxStep &amp;&amp; i + k &lt; len; k++) { if (dp[i + k] == 1) { dp[i] = 1; break; } } } return dp[0] == 1;}// optimized DP, Time Complexity O(n)public boolean canJump2(int[] nums) { if (nums == null || nums.length == 0) { return false; } int len = nums.length; // in the DP solution, we only use the left most index that can reach the end int leftMostGood = len - 1; for (int i = len - 2; i &gt;= 0; i--) { if (i + nums[i] &gt;= leftMostGood) { // i is a good index leftMostGood = i; } } // whether index 0 is a good index return leftMostGood == 0;}","link":"/2022/01/25/LeetCode-55-Jump-Game/"},{"title":"LeetCode 1306. Jump Game III","text":"QuestionGiven an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time. Example 1: 123456Input: arr = [4,2,3,0,3,1,2], start = 5Output: trueExplanation: All possible ways to reach at index 3 with value 0 are: index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 2: 12345Input: arr = [4,2,3,0,3,1,2], start = 0Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 3: 123Input: arr = [3,0,2,1,2], start = 2Output: falseExplanation: There is no way to reach at index 1 with value 0. Constraints: 1 &lt;= arr.length &lt;= 5 * 104 0 &lt;= arr[i] &lt; arr.length 0 &lt;= start &lt; arr.length Source: https://leetcode.com/problems/jump-game-iii/ SolutionFor jump games, if one path reaches a visited point, we can terminate that path (pruning). Because it can be replaced by a previous path. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// BFS, Time Complexity O(n)public boolean canReach(int[] arr, int start) { int len = arr.length; boolean[] visited = new boolean[len]; // initialized with false Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // store indexes queue.add(start); while (!queue.isEmpty()) { int currIndex = queue.poll(); // if current path includes a visited index, it can be replaced if (visited[currIndex]) { continue; } if (arr[currIndex] == 0) { return true; } visited[currIndex] = true; if (currIndex + arr[currIndex] &lt; len) { queue.add(currIndex + arr[currIndex]); } if (currIndex - arr[currIndex] &gt;= 0) { queue.add(currIndex - arr[currIndex]); } } return false;}private boolean dfs(int[] arr, boolean[] visited, int start, int len) { if (start &lt; 0 || start &gt;= len || visited[start]) { return false; } if (arr[start] == 0) { return true; } visited[start] = true; return dfs(arr, visited, start - arr[start], len) || dfs(arr, visited, start + arr[start], len);}// DFS, Time Complexity O(n)public boolean canReach2(int[] arr, int start) { int len = arr.length; boolean[] visited = new boolean[len]; // initialized with false return dfs(arr, visited, start, len);}","link":"/2022/01/25/LeetCode-1306-Jump-Game-III/"},{"title":"LeetCode 45. Jump Game II","text":"QuestionGiven an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Example 1: 123Input: nums = [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 12Input: nums = [2,3,0,1,4]Output: 2 Constraints: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 1000 Source: https://leetcode.com/problems/jump-game-ii/ Solution1D DP. dp[i] is the min number of jumps from i to the end. 123456789101112131415161718192021222324252627282930// DP, Time Complexity O(n^2)public int jump(int[] nums) { if (nums == null || nums.length == 0) { return -1; } int len = nums.length; // dp[i] is the min number of jumps from i to the end // if i cannot reach the end, dp[i] should be -1 int[] dp = new int[len]; for (int i = 0; i &lt; len; i++) { dp[i] = -1; } dp[len - 1] = 0; for (int i = len - 2; i &gt;= 0; i--) { int maxStep = nums[i]; int minJump = Integer.MAX_VALUE; boolean isGood = false; for (int k = 0; k &lt;= maxStep &amp;&amp; i + k &lt; len; k++) { // if i+k can reach the end if (dp[i + k] != -1) { isGood = true; minJump = Math.min(minJump, dp[i + k] + 1); } } if (isGood) { dp[i] = minJump; } } return dp[0];}","link":"/2022/01/25/LeetCode-45-Jump-Game-II/"},{"title":"LeetCode 1345. Jump Game IV","text":"QuestionGiven an array of integers arr, you are initially positioned at the first index of the array. In one step you can jump from index i to index: i + 1 where: i + 1 &lt; arr.length. i - 1 where: i - 1 &gt;= 0. j where: arr[i] == arr[j] and i != j. Return the minimum number of steps to reach the last index of the array. Notice that you can not jump outside of the array at any time. Example 1: 123Input: arr = [100,-23,-23,404,100,23,23,23,3,404]Output: 3Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array. Example 2: 123Input: arr = [7]Output: 0Explanation: Start index is the last index. You do not need to jump. Example 3: 123Input: arr = [7,6,9,6,9,6,9,7]Output: 1Explanation: You can jump directly from index 0 to index 7 which is last index of the array. Constraints: 1 &lt;= arr.length &lt;= 5 * 104 -108 &lt;= arr[i] &lt;= 108 Source: https://leetcode.com/problems/jump-game-iv/ SolutionThe idea of using queue size is to achieve layer-order traversal, like LeetCode 102. Binary Tree Level Order Traversal. So we can record the length of current search paths easily. Repeated visits to nodes with the same value are not helpful in getting the min number of steps to the end. Thus, we can prune the BFS tree. Note that marking those nodes as visited is not enough. We need to clear corresponding key-value pair in the valueIndexMap. Because as long as these nodes are pushed to the queue, they will increase time cost. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int minJumps(int[] arr) { int len = arr.length; // value -&gt; list of indexes that have the same value arr[i] Map&lt;Integer, List&lt;Integer&gt;&gt; valueIndexMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; i++) { if (valueIndexMap.containsKey(arr[i])) { List&lt;Integer&gt; list = valueIndexMap.get(arr[i]); list.add(i); } else { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(i); valueIndexMap.put(arr[i], list); } } int pathLen = 0; boolean[] visited = new boolean[len]; // initialized with false Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // stored indexes queue.add(0); while (!queue.isEmpty()) { int size = queue.size(); // traverse in layer order for (int i = 0; i &lt; size; i++) { int currIndex = queue.poll(); if (visited[currIndex]) { continue; } if (currIndex == len - 1) { // the first return path is the shortest path return pathLen; } visited[currIndex] = true; if (currIndex - 1 &gt;= 0) { queue.add(currIndex - 1); } if (currIndex + 1 &lt; len) { queue.add(currIndex + 1); } for (int index : valueIndexMap.get(arr[currIndex])) { if (index != currIndex) { queue.add(index); } } // there is no meaning to teleport to the same value on current and further iterations // only produce paths with identical or larger length // so that to waive repeated inner loop valueIndexMap.get(arr[currIndex]).clear(); } pathLen++; } return -1;}","link":"/2022/01/25/LeetCode-1345-Jump-Game-IV/"},{"title":"LeetCode 46. Permutations","text":"QuestionGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: 12Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2: 12Input: nums = [0,1]Output: [[0,1],[1,0]] Example 3: 12Input: nums = [1]Output: [[1]] Constraints: 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 All the integers of nums are unique. Source: https://leetcode.com/problems/permutations/ SolutionA conveninent condition provided by this question is that all elements are distinct. Thus, we do not need to consider duplicates of result. The following solution is based on swap() so that it does not require additional space to store intermediate result of permutations. The idea is similar to selection sort. We treat elements before position as a determined permutation prefix, treat element after position as available elements in future searches. Another point is backtracking. Because all operations are on the same array nums, we need to recover changes of subtrees before diving into another path. A common trick for DFS problems is to draw a DFS tree. 12345678910111213141516171819202122232425262728293031private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;}// the depth of dfs equals to the length of the array// elements before position are regarded as fixedprivate void dfs(int[] nums, int position, List&lt;List&lt;Integer&gt;&gt; result) { if (position == nums.length - 1) { List&lt;Integer&gt; permutation = new ArrayList&lt;&gt;(); for (int n : nums) { permutation.add(n); } result.add(permutation); } // CANNOT guarantee that result will be de-deduplicated for (int i = position; i &lt; nums.length; i++) { // backtrace swap(nums, position, i); dfs(nums, position + 1, result); swap(nums, position, i); }}public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); dfs(nums, 0, permutations); return permutations;}","link":"/2022/03/06/LeetCode-46-Permutations/"},{"title":"LeetCode 47. Permutations II","text":"QuestionGiven a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: 12345Input: nums = [1,1,2]Output:[[1,1,2], [1,2,1], [2,1,1]] Example 2: 12Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Constraints: 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 Source: https://leetcode.com/problems/permutations-ii/ SolutionThe following code shows two solutions for this problem. One constructs permutations by swap, the other by append. The idea of swap solution is explained in detail in post LeetCode 46. Permutations. The key point of de-duplication is to avoid traversing duplicate elements on the same DFS layer. By doing so, we can avoid duplicate permutation prefixes. Because constructing permutations is a recursive process, we guarantee that there is no duplicates in the final result. The swap solution achieves this by maintaining a set for each layer. For the append solution, we choose to use a character-count map. And on each layer, we traverse its key set rather than entry set so that we avoid duplicate elements. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;}// the depth of dfs equals to the length of the array// elements before position are regarded as fixedprivate void dfs(int[] nums, int position, List&lt;List&lt;Integer&gt;&gt; result) { if (position == nums.length - 1) { List&lt;Integer&gt; permutation = new ArrayList&lt;&gt;(); for (int n : nums) { permutation.add(n); } result.add(permutation); } // to store used elements in this layer // if two prefixes are identical, their dfs results must contain duplicates Set&lt;Integer&gt; used = new HashSet&lt;&gt;(); for (int i = position; i &lt; nums.length; i++) { if (!used.contains(nums[i])) { used.add(nums[i]); // backtrace swap(nums, position, i); dfs(nums, position + 1, result); swap(nums, position, i); } }}public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; unique = new ArrayList&lt;&gt;(); dfs(nums, 0, unique); return unique;}// the depth of dfs equals to the length of the array// elements before position are regarded as fixedprivate void dfs2(int length, LinkedList&lt;Integer&gt; current, Map&lt;Integer, Integer&gt; dict, List&lt;List&lt;Integer&gt;&gt; result) { if (current.size() == length) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); } // traverse its key set instead of entry set to avoid duplicates for (Integer e : dict.keySet()) { int count = dict.get(e); if (count == 0) { continue; } // backtrace // do not remove key even if its value is 0, so as not to interfere map traversal current.addLast(e); dict.put(e, count - 1); dfs2(length, current, dict, result); current.removeLast(); dict.put(e, count); }}public List&lt;List&lt;Integer&gt;&gt; permuteUnique2(int[] nums) { List&lt;List&lt;Integer&gt;&gt; unique = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); LinkedList&lt;Integer&gt; permute = new LinkedList&lt;&gt;(); for (int n : nums) { map.put(n, map.getOrDefault(n, 0) + 1); } dfs2(nums.length, permute, map, unique); return unique;}","link":"/2022/03/06/LeetCode-47-Permutations-II/"},{"title":"LeetCode 60. Permutation Sequence","text":"QuestionThe set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; Given n and k, return the kth permutation sequence. Example 1: 12Input: n = 3, k = 3Output: &quot;213&quot; Example 2: 12Input: n = 4, k = 9Output: &quot;2314&quot; Example 3: 12Input: n = 3, k = 1Output: &quot;123&quot; Constraints: 1 &lt;= n &lt;= 9 1 &lt;= k &lt;= n! Source: https://leetcode.com/problems/permutation-sequence/ SolutionWe find the result digit by digit. For each digit, we can determine its value by dividing k by the number of permutations of its suffix. By subtracting the number of skipped permutations from k, we keep narrowing k till we find a certain permutation. Note that in each loop we need to removed current digit because we cannot reuse numbers. Also, permutations are in a lexicographic order, so we should keep nums sorted. Remove operations do not break the order of nums. 12345678910111213141516171819202122232425262728// Time Complexity, O(n)public String getPermutation(int n, int k) { StringBuilder result = new StringBuilder(); List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) { nums.add(i); } // [0!, 1!, ..., (n-1)!] int[] factorials = new int[n]; factorials[0] = 1; for (int i = 1; i &lt; n; i++) { factorials[i] = i * factorials[i - 1]; } // make k start from 0, // so that the result of k / factorials[n - pos - 1] has the same meaning as an index of nums k -= 1; // [1 (2 3 4 5)] (n-1)!=4! // [3 5 4 (1 2)] (n-3)!=2! // [3 5 4 2 1()] (n-5)!=0! for (int pos = 0; pos &lt; n; pos++) { int index = k / factorials[n - pos - 1]; // skip suffix permutations as much as possible result.append(nums.get(index)); nums.remove(index); // removing elements does not break the order of the list k -= index * factorials[n - pos - 1]; } return result.toString();}","link":"/2022/03/06/LeetCode-60-Permutation-Sequence/"},{"title":"LeetCode 31. Next Permutation","text":"QuestionA permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: 12Input: nums = [1,2,3]Output: [1,3,2] Example 2: 12Input: nums = [3,2,1]Output: [1,2,3] Example 3: 12Input: nums = [1,1,5]Output: [1,5,1] Constraints: 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 100 Source: https://leetcode.com/problems/next-permutation/ SolutionOur idea is similar to carry in addition. We need to find the longest non-increasing suffix and perform a carry operation on this suffix, so that we get the next permutation. Specifically, we swap the digit before this suffix (nums[pivot]) with an element just greater than the digit (from right to left in the suffix, find the first element that is larger than the pivot). Then we reverse the suffix to make it non-decreasing so that the new suffix is the “smallest” permutation of itself. Here are several points worth noting. First, an element greater than pivot must exist in the suffix. Because this suffix is the longest non-increasing suffix, pivot at least is smaller than the first element in the suffix. Second, after swap, the new suffix is still non-increasing because elements in the left of the swap position must be equal to or less than the pivot. This is guaranteed by our search strategy. 12345678910111213141516171819202122232425262728293031323334353637383940414243private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;}// reverse elements in [i, j]private void reverse(int[] nums, int i, int j) { while (i &lt; j) { swap(nums, i, j); i++; j--; }}// Time Complexity, O(n)public void nextPermutation(int[] nums) { if (nums == null || nums.length &lt;= 1) { return; } // find the longest non-increasing suffix int pivot = nums.length - 2; // find the pivot before the longest non-increasing suffix while (pivot &gt;= 0 &amp;&amp; nums[pivot] &gt;= nums[pivot + 1]) { pivot--; } if (pivot &gt;= 0) { // from right to left in the suffix, find the first element that is larger than the pivot // &quot;first&quot; is important for keeping suffix non-increasing int j = nums.length - 1; for (; j &gt;= pivot + 1; j--) { if (nums[j] &gt; nums[pivot]) { break; } } // swap and make the suffix non-decreasing by reversing it swap(nums, pivot, j); reverse(nums, pivot + 1, nums.length - 1); } else { // nums is the last permutation // turn it to the first permutation reverse(nums, pivot + 1, nums.length - 1); }} Example","link":"/2022/03/06/LeetCode-31-Next-Permutation/"},{"title":"LeetCode 266. Palindrome Permutation","text":"QuestionGiven a string s, return true if a permutation of the string could form a palindrome. Example 1: 12Input: s = &quot;code&quot;Output: false Example 2: 12Input: s = &quot;aab&quot;Output: true Example 3: 12Input: s = &quot;carerac&quot;Output: true Constraints: 1 &lt;= s.length &lt;= 5000 s consists of only lowercase English letters. Source: https://leetcode.com/problems/palindrome-permutation/ Solution12345678910111213141516171819202122232425262728public boolean canPermutePalindrome(String s) { Map&lt;Character, Integer&gt; charCount = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); charCount.put(c, charCount.getOrDefault(c, 0) + 1); } int oddCount = 0; for (int count : charCount.values()) { if (count % 2 == 1) { oddCount++; } } // at most one character can appear odd times return oddCount == 0 || oddCount == 1;}public boolean canPermutePalindrome2(String s) { Set&lt;Character&gt; charSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if (charSet.contains(c)) { charSet.remove(c); } else { charSet.add(c); } } return charSet.size() == 0 || charSet.size() == 1;}","link":"/2022/03/06/LeetCode-266-Palindrome-Permutation/"},{"title":"LeetCode 77. Combinations","text":"QuestionGiven two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order. Example 1: 12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] Example 2: 12Input: n = 1, k = 1Output: [[1]] Constraints: 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= n Source: https://leetcode.com/problems/combinations/ SolutionThe following code is based on the append solution of LeetCode 47. Permutations II. Why not swap-based solution? Because available elements in this question are not a fixed set but can be different subsets of [1, n]. Because combinations do not care about order, we can get combinations by restricting permutations to an ascending order. It is ok if the value on current position is too large to leave enough space for deeper layers. DFS paths just safely return to last layer before reach kth layer (leave layer). 12345678910111213141516171819202122232425// start is the smallest valid value for current positionprivate void dfs(int n, int k, int start, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) { if (current.size() == k) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); return; } // combinations do not care about order // we can get combinations by restricting permutations to an ascending order // it is ok if the value on current position is too large to leave enough space for deeper layers // dfs paths just safely return to last layer before reach kth layer (leave layer) for (int i = start; i &lt;= n; i++) { current.addLast(i); dfs(n, k, i + 1, current, result); current.removeLast(); }}public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { LinkedList&lt;Integer&gt; comb = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; combines = new ArrayList&lt;&gt;(); dfs(n, k, 1, comb, combines); return combines;}","link":"/2022/03/06/LeetCode-77-Combinations/"},{"title":"LeetCode 39. Combination Sum","text":"QuestionGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: 123456Input: candidates = [2,3,6,7], target = 7Output: [[2,2,3],[7]]Explanation:2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.7 is a candidate, and 7 = 7.These are the only two combinations. Example 2: 12Input: candidates = [2,3,5], target = 8Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3: 12Input: candidates = [2], target = 1Output: [] Constraints: 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 All elements of candidates are distinct. 1 &lt;= target &lt;= 500 Source: https://leetcode.com/problems/combination-sum/ SolutionWe are given a distinct candidates array, so we do not need to use a set to avoid duplicates like in LeetCode 47. Permutations II. Just by making elements of every combination in a non-decreasing order, we can get unique combinations. Pre-sorting helps us find valid candidates faster. When the candidates array is sorted, we can pass start position rather than start value to the deeper layer of DFS tree. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void dfs(int[] candidates, int start, int target, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) { if (target &lt; 0) { return; } if (target == 0) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); return; } for (int candi : candidates) { // combinations in non-decreasing order if (candi &gt;= start) { // backtrace current.addLast(candi); dfs(candidates, candi, target - candi, current, result); current.removeLast(); } }}public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; comb = new LinkedList&lt;&gt;(); dfs(candidates, 0, target, comb, result); return result;}// improve performance under the same time complexity// through pre-sorting candidates so that we can find valid candidates easilyprivate void dfs2(int[] sortedCandidates, int startPos, int target, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) { if (target &lt; 0) { return; } if (target == 0) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); return; } // combinations in non-decreasing order for (int i = startPos; i &lt; sortedCandidates.length; i++) { int candi = sortedCandidates[i]; // backtrace current.addLast(candi); dfs2(sortedCandidates, i, target - candi, current, result); current.removeLast(); }}public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; comb = new LinkedList&lt;&gt;(); Arrays.sort(candidates); dfs2(candidates, 0, target, comb, result); return result;}","link":"/2022/03/06/LeetCode-39-Combination-Sum/"},{"title":"LeetCode 40. Combination Sum II","text":"QuestionGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. Example 1: 12345678Input: candidates = [10,1,2,7,6,1,5], target = 8Output: [[1,1,6],[1,2,5],[1,7],[2,6]] Example 2: 123456Input: candidates = [2,5,2,1,2], target = 5Output: [[1,2,2],[5]] Constraints: 1 &lt;= candidates.length &lt;= 100 1 &lt;= candidates[i] &lt;= 50 1 &lt;= target &lt;= 30 Source: https://leetcode.com/problems/combination-sum-ii/ SolutionThis time we do not have distinct and reuse these two conveninent features. So we use pre-sorting and set to avoid duplicates. dfs2 provides another way to skip duplicate elements on the same layer. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// depth of a dfs path is the length of the combination (variable)// pre-sorting makes candidates with the same value be grouped together// we can find valid candidates easilyprivate void dfs(int[] sortedCandidates, int startPos, int target, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) { if (target &lt; 0) { return; } if (target == 0) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); return; } Set&lt;Integer&gt; used = new HashSet&lt;&gt;(); // combinations in non-decreasing order for (int i = startPos; i &lt; sortedCandidates.length; i++) { int candi = sortedCandidates[i]; // avoid adding duplicates in the same layer if (used.contains(candi)) { continue; } else { used.add(candi); } // backtrace current.addLast(candi); dfs(sortedCandidates, i + 1, target - candi, current, result); current.removeLast(); }}// another way to avoid duplicatesprivate void dfs2(int[] sortedCandidates, int startPos, int target, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) { if (target &lt; 0) { return; } if (target == 0) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); return; } // combinations in non-decreasing order for (int i = startPos; i &lt; sortedCandidates.length; i++) { int candi = sortedCandidates[i]; // avoid adding duplicates in the same layer if (i != startPos &amp;&amp; candi == sortedCandidates[i - 1]) { continue; } // backtrace current.addLast(candi); dfs2(sortedCandidates, i + 1, target - candi, current, result); current.removeLast(); }}public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; comb = new LinkedList&lt;&gt;(); Arrays.sort(candidates); dfs(candidates, 0, target, comb, result); // dfs2(candidates, 0, target, comb, result); return result;}","link":"/2022/03/06/LeetCode-40-Combination-Sum-II/"},{"title":"LeetCode 90. Subsets II","text":"QuestionGiven an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: 12Input: nums = [1,2,2]Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Example 2: 12Input: nums = [0]Output: [[],[0]] Constraints: 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 Source: https://leetcode.com/problems/subsets-ii/ SolutionSet is a kind of combination without constraint of length. The given array may contain duplicates. So we pre-sort nums, which enables us to conveninently skip duplicate elements on DFS layers. 123456789101112131415161718192021222324252627282930private void dfs(int[] sortedNums, int startPos, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) { if (startPos == sortedNums.length) { List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(current); result.add(copy); return; } // do not add any more elements // regarded as a subset dfs(sortedNums, sortedNums.length, current, result); for (int i = startPos; i &lt; sortedNums.length; i++) { int n = sortedNums[i]; // skip used elements in this layer if (i != startPos &amp;&amp; sortedNums[i] == sortedNums[i - 1]) { continue; } // backtrace current.addLast(n); dfs(sortedNums, i + 1, current, result); current.removeLast(); }}public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { List&lt;List&lt;Integer&gt;&gt; subsets = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; subset = new LinkedList&lt;&gt;(); Arrays.sort(nums); dfs(nums, 0, subset, subsets); return subsets;}","link":"/2022/03/06/LeetCode-90-Subsets-II/"},{"title":"LeetCode 236. Lowest Common Ancestor of a Binary Tree","text":"QuestionGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: 12Input: root = [1,2], p = 1, q = 2Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 &lt;= Node.val &lt;= 109 All Node.val are unique. p != q p and q will exist in the tree. Source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ SolutionDFS. Use the return value of recursive function to reflect the existence of p, q and their lowest common ancestor. The following implementation is feasible but no recommended, because the return value has multiple meanings. 1234567891011121314151617181920212223242526272829303132333435363738static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}// one important prerequisite is that p and q must be in the whole tree// the return value has multiple meanings (NOT a good design):// if null, neither p nor q exists in the tree of root;// if not null, at least one of p and q exists in the tree of root,// if p and q exist in the left and right subtree of root respectively, return root itself.// because in this case, root is the lowest common ancestorprivate TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode leftResult = dfs(root.left, p, q); TreeNode rightResult = dfs(root.right, p, q); if (leftResult != null &amp;&amp; rightResult != null) { // root is the lowest common ancestor return root; } else if (leftResult != null) { return leftResult; } else if (rightResult != null) { return rightResult; } else { return null; }}public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return dfs(root, p, q);}","link":"/2022/03/08/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"},{"title":"LeetCode 1644. Lowest Common Ancestor of a Binary Tree II","text":"QuestionGiven the root of a binary tree, return the lowest common ancestor (LCA) of two given nodes, p and q. If either node p or q does not exist in the tree, return null. All values of the nodes in the tree are unique. According to the definition of LCA on Wikipedia: “The lowest common ancestor of two nodes p and q in a binary tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself)”. A descendant of a node x is a node y that is on the path from node x to some leaf node. Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5. A node can be a descendant of itself according to the definition of LCA. Example 3: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10Output: nullExplanation: Node 10 does not exist in the tree, so return null. Constraints: The number of nodes in the tree is in the range [1, 104]. -109 &lt;= Node.val &lt;= 109 All Node.val are unique. p != q Source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/ SolutionThe solution in LeetCode 236. Lowest Common Ancestor of a Binary Tree cannot solve this question because p or q may not exist in the tree. The following solution separates the information for existence and the information for result (lowest common ancestor reference), so that fix that flaw. 1234567891011121314151617181920212223242526272829303132333435363738static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}private TreeNode lca = null;// return the number of target nodes in the tree of root// separate lca information and target occurrence informationprivate int dfs(TreeNode root, TreeNode p, TreeNode q) { if (root == null) { return 0; } int count = 0; if (root == p || root == q) { count++; } count += dfs(root.left, p, q); count += dfs(root.right, p, q); // only set lca once when encountering the lowest common ancestor if (count == 2 &amp;&amp; lca == null) { lca = root; } return count;}public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { lca = null; dfs(root, p, q); return lca;}","link":"/2022/03/08/LeetCode-1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II/"},{"title":"LeetCode 160. Intersection of Two Linked Lists","text":"QuestionGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. listA - The first linked list. listB - The second linked list. skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node. The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1: 1234Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3Output: Intersected at '8'Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: 1234Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: No intersectionExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Constraints: The number of nodes of listA is in the m. The number of nodes of listB is in the n. 1 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt; m 0 &lt;= skipB &lt; n intersectVal is 0 if listA and listB do not intersect. intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect. Follow up: Could you write a solution that runs in O(m + n) time and use only O(1) memory? Source: https://leetcode.com/problems/intersection-of-two-linked-lists/ Solution12345678910111213141516171819202122public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode pa = headA; ListNode pb = headB; // -- aLen -- \\ // -- commonLen -- // -- bLen -- / // aLen + commonLen + bLen == bLen + commonLen + aLen while (pa != pb) { if (pa == null) { pa = headB; continue; } if (pb == null) { pb = headA; continue; } pa = pa.next; pb = pb.next; } return pa;}","link":"/2022/03/09/LeetCode-160-Intersection-of-Two-Linked-Lists/"},{"title":"LeetCode 1650. Lowest Common Ancestor of a Binary Tree III","text":"QuestionGiven two nodes of a binary tree p and q, return their lowest common ancestor (LCA). Each node will have a reference to its parent node. The definition for Node is below: 123456class Node { public int val; public Node left; public Node right; public Node parent;} According to the definition of LCA on Wikipedia: “The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition. Constraints: The number of nodes in the tree is in the range [2, 105]. -109 &lt;= Node.val &lt;= 109 All Node.val are unique. p != q p and q exist in the tree. Source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ SolutionThis question is actually a disguised LeetCode 160. Intersection of Two Linked Lists. The lowest common ancestor is the head of intersection list. 1234567891011121314151617public Node lowestCommonAncestor(Node p, Node q) { Node first = p; Node second = q; while (first != second) { if (first == null) { first = q; continue; } if (second == null) { second = p; continue; } first = first.parent; second = second.parent; } return first;}","link":"/2022/03/09/LeetCode-1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III/"},{"title":"LeetCode 1676. Lowest Common Ancestor of a Binary Tree IV","text":"QuestionGiven the root of a binary tree and an array of TreeNode objects nodes, return the lowest common ancestor (LCA) of all the nodes in nodes. All the nodes will exist in the tree, and all values of the tree’s nodes are unique. Extending the definition of LCA on Wikipedia: “The lowest common ancestor of n nodes p1, p2, …, pn in a binary tree T is the lowest node that has every pi as a descendant (where we allow a node to be a descendant of itself) for every valid i“. A descendant of a node x is a node y that is on the path from node x to some leaf node. Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [4,7]Output: 2Explanation: The lowest common ancestor of nodes 4 and 7 is node 2. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [1]Output: 1Explanation: The lowest common ancestor of a single node is the node itself. Constraints: The number of nodes in the tree is in the range [1, 104]. -109 &lt;= Node.val &lt;= 109 All Node.val are unique. All nodes[i] will exist in the tree. All nodes[i] are distinct. Source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/ Solution1234567891011121314151617181920212223242526272829private TreeNode lca = null;// return the number of target nodes in the tree of root// separate lca information and target occurrence informationprivate int dfs(TreeNode root, Set&lt;TreeNode&gt; set) { if (root == null) { return 0; } int count = 0; if (set.contains(root)) { count++; } count += dfs(root.left, set); count += dfs(root.right, set); // only set lca once when encountering the lowest common ancestor if (count == set.size() &amp;&amp; lca == null) { lca = root; } return count;}public TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) { lca = null; Set&lt;TreeNode&gt; nodeSet = new HashSet&lt;&gt;(Arrays.asList(nodes)); dfs(root, nodeSet); return lca;}","link":"/2022/03/09/LeetCode-1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV/"},{"title":"LeetCode 235. Lowest Common Ancestor of a Binary Search Tree","text":"QuestionGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Constraints: The number of nodes in the tree is in the range [2, 105]. -109 &lt;= Node.val &lt;= 109 All Node.val are unique. p != q p and q will exist in the BST. Source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// If BST is balanced, Time Complexity O(log(n))// Worst Time Complexity O(n)// return the lowest common ancestor// with an assumption that p and q must exist in treeprivate TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) { if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) { // both p, q in the left tree return dfs(root.left, p, q); } else if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) { // both p, q in the right tree return dfs(root.right, p, q); } else { // p or q is current root, // or p and q are in two different subtrees respectively // in either case, current root is the lowest common ancestor return root; }}public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return dfs(root, p, q);}private TreeNode lca = null;// an accelerated brutal force DFS, so has higher time complexity// but works for cases that p and q may not exist in the treeprivate int dfs2(TreeNode root, TreeNode p, TreeNode q) { if (root == null) { return 0; } int count = 0; if (root == p || root == q) { count++; } if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) { count += dfs2(root.left, p, q); } else if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) { count += dfs2(root.right, p, q); } else { count += dfs2(root.left, p, q); count += dfs2(root.right, p, q); } if (count == 2 &amp;&amp; lca == null) { lca = root; } return count;}public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) { lca = null; dfs2(root, p, q); return lca;}","link":"/2022/03/09/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"},{"title":"LeetCode 528. Random Pick with Weight","text":"QuestionYou are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w). For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%). Constraints: 1 &lt;= w.length &lt;= 104 1 &lt;= w[i] &lt;= 105 pickIndex will be called at most 104 times. Source: https://leetcode.com/problems/random-pick-with-weight/ SolutionIn theory, we create several intervals from the weight array. Then generate a random value. In which interval the random value falls, the corresponding index is returned. The key point is how to determine which interval the random value falls. We use binary search so that the time complexity is O(log(n)). In Java, TreeMap is implemented based on Red-Black tree, a kind of self-balancing binary search tree. Thus, we can also use TreeMap to get the same time complexity. class RandomPickWithWeight Use TreeMap to store lower bounds. 123456789101112131415161718192021// lower bound -&gt; indexprivate TreeMap&lt;Integer, Integer&gt; treeMap;private Random rand;private int scope;public RandomPickWithWeight(int[] w) { treeMap = new TreeMap&lt;&gt;(); rand = new Random(System.currentTimeMillis()); int lowerBound = 0; for (int i = 0; i &lt; w.length; i++) { treeMap.put(lowerBound, i); lowerBound += w[i]; } scope = lowerBound;}public int pickIndex() { // avoid negative random number int r = Math.abs(rand.nextInt() % scope); return treeMap.floorEntry(r).getValue();} Use prefix sum and binary search. Prefix sum array represents upper bounds. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Random rand;private int scope;// upper bounds, (,]private int[] prefixSums;public RandomPickWithWeightAlt1(int[] w) { rand = new Random(System.currentTimeMillis()); prefixSums = new int[w.length]; prefixSums[0] = w[0]; for (int i = 1; i &lt; w.length; i++) { prefixSums[i] = prefixSums[i - 1] + w[i]; } scope = prefixSums[w.length - 1];}public int pickIndex() { // nextInt(n) returns a random number in [0,n) int r = rand.nextInt(scope) + 1; int len = prefixSums.length; // both ends of the search window are inclusive int left = 0, right = len - 1; // mid is rounded to the floor, so left must make progress while (left &lt; right) { int mid = left + (right - left) / 2; // prevent overflow if (r == prefixSums[mid]) { return mid; } else if (r &lt; prefixSums[mid]) { right = mid; } else { left = mid + 1; } } // left and right should be the same here // but using right is easier to understand return right;}public int pickIndex2() { // nextInt(n) returns a random number in [0,n) int r = rand.nextInt(scope) + 1; int len = prefixSums.length; // both ends of the search window are inclusive int left = 0, right = len - 1; // another implementation of binary search // avoid the case that left == mid while (left &lt; right - 1) { int mid = left + (right - left) / 2; // prevent overflow if (r == prefixSums[mid]) { return mid; } else if (r &lt; prefixSums[mid]) { right = mid; } else { left = mid + 1; } } // out of the loop, left == right or left are adjacent with right if (r &lt;= prefixSums[left] &amp;&amp; r &lt;= prefixSums[right]) { return left; } else { return right; }}","link":"/2022/03/09/LeetCode-528-Random-Pick-with-Weight/"},{"title":"LeetCode 35. Search Insert Position","text":"QuestionGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Example 1: 12Input: nums = [1,3,5,6], target = 5Output: 2 Example 2: 12Input: nums = [1,3,5,6], target = 2Output: 1 Example 3: 12Input: nums = [1,3,5,6], target = 7Output: 4 Constraints: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums contains distinct values sorted in ascending order. -104 &lt;= target &lt;= 104 Source: https://leetcode.com/problems/search-insert-position/ Solution12345678910111213141516171819202122232425public int searchInsert(int[] nums, int target) { int len = nums.length; int left = 0, right = len - 1; // mid is rounded to the floor, so left must make progress while (left &lt; right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &gt; target) { right = mid; } else { left = mid + 1; } } // out of the loop, left == right if (nums[left] == target) { return left; } else if (nums[left] &lt; target) { return right + 1; } else { return left; }}","link":"/2022/03/09/LeetCode-35-Search-Insert-Position/"},{"title":"LeetCode 33. Search in Rotated Sorted Array","text":"QuestionThere is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 Example 3: 12Input: nums = [1], target = 0Output: -1 Constraints: 1 &lt;= nums.length &lt;= 5000 -104 &lt;= nums[i] &lt;= 104 All values of nums are unique. nums is an ascending array that is possibly rotated. -104 &lt;= target &lt;= 104 Source: https://leetcode.com/problems/search-in-rotated-sorted-array/ SolutionThe main idea is first using binary search to find the pivot and then performing another binary search on a part of the array. For the binary search in findPivot, left must be adjacent to right (not overlapped). Because we use a conservative strategy to move pointers (left = mid, right = mid). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// find the pivot of rotated sorted array// that divide nums into two interval: [:pivot), [pivot:]// @pre: nums only contains distinct numbersprivate int findPivot(int[] nums) { int len = nums.length; int left = 0, right = len - 1; if (nums[left] &lt; nums[right]) { return 0; } while (left &lt; right - 1) { int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[left]) { left = mid; } else { right = mid; } } return right;}// normal binary search, assume nums is ascending in [left, right]private int binarySearch(int[] nums, int left, int right, int target) { while (left &lt; right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid; } } return nums[left] == target ? left : -1;}public int search(int[] nums, int target) { // cope with cases of length &lt;= 1 if (nums == null || nums.length == 0) { return -1; } if (nums.length == 1) { return target == nums[0] ? 0 : -1; } int len = nums.length; int pivot = findPivot(nums); // handle special case that there is only one interval if (pivot == 0) { return binarySearch(nums, 0, len - 1, target); } if (target &gt;= nums[0]) { return binarySearch(nums, 0, pivot - 1, target); } else { return binarySearch(nums, pivot, len - 1, target); }}","link":"/2022/03/09/LeetCode-33-Search-in-Rotated-Sorted-Array/"},{"title":"LeetCode 41. First Missing Positive","text":"QuestionGiven an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space. Example 1: 12Input: nums = [1,2,0]Output: 3 Example 2: 12Input: nums = [3,4,-1,1]Output: 2 Example 3: 12Input: nums = [7,8,9,11,12]Output: 1 Constraints: 1 &lt;= nums.length &lt;= 5 * 105 -231 &lt;= nums[i] &lt;= 231 - 1 Source: https://leetcode.com/problems/first-missing-positive/ SolutionWe try to put every positive number n on the position n-1. Then we traverse the array to find the first number that num[i] != i + 1, so that we get the first missing positive number. Note that there may be duplicate values that fit in the same position. We should skip the rest of them to avoid endless loop. 12345678910111213141516171819202122232425262728293031private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;}public int firstMissingPositive(int[] nums) { int i = 0; // in-place // num should on the num - 1 position // put elements to the correct position if possible while (i &lt; nums.length) { int num = nums[i]; if (num &lt;= 0 || num == i + 1 || num - 1 &gt;= nums.length) { // skip i++; } else if (num == nums[num - 1]) { // multiple elements fit the same position // prevent endless loop i++; } else { // do not update i here swap(nums, i, num - 1); } } i = 0; for (; i &lt; nums.length; i++) { if (nums[i] != i + 1) { break; } } return i + 1;}","link":"/2022/03/09/LeetCode-41-First-Missing-Positive/"}],"tags":[{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Monotonic","slug":"Monotonic","link":"/tags/Monotonic/"},{"name":"Delta","slug":"Delta","link":"/tags/Delta/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Substring","slug":"Substring","link":"/tags/Substring/"},{"name":"Common Substring","slug":"Common-Substring","link":"/tags/Common-Substring/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Prefix Sum","slug":"Prefix-Sum","link":"/tags/Prefix-Sum/"},{"name":"Rolling Hash","slug":"Rolling-Hash","link":"/tags/Rolling-Hash/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Interval","slug":"Interval","link":"/tags/Interval/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Coloring","slug":"Coloring","link":"/tags/Coloring/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"Greedy","slug":"Greedy","link":"/tags/Greedy/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"Backtrace","slug":"Backtrace","link":"/tags/Backtrace/"},{"name":"Subset","slug":"Subset","link":"/tags/Subset/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"In-place","slug":"In-place","link":"/tags/In-place/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Programming Tips","slug":"Programming-Tips","link":"/categories/Programming-Tips/"},{"name":"Algorithm Template","slug":"Algorithm-Template","link":"/categories/Algorithm-Template/"},{"name":"C - K&amp;R","slug":"C-K-R","link":"/categories/C-K-R/"},{"name":"Math","slug":"Math","link":"/categories/Math/"}]}